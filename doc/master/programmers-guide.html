<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Programmers Guide &mdash; AtomVM 0.6.0-alpha.1+git.d995f51c documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="canonical" href="https://atomvm.net/doc/programmers-guide.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Example Programs" href="example-programs.html" />
    <link rel="prev" title="Getting Started Guide" href="getting-started-guide.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/avm_logo_banner.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                master
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="welcome-to-atomvm.html">Welcome to AtomVM!</a></li>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting-started-guide.html">Getting Started Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Programmers Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#atomvm-features">AtomVM Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#atomvm-development">AtomVM Development</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#development-environment">Development Environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#esp32-deployment-requirements">ESP32 Deployment Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stm32-deployment-requirements">STM32 Deployment Requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#development-workflow">Development Workflow</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#applications">Applications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#packbeam-files">Packbeam files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#packbeam-tool"><code class="docutils literal notranslate"><span class="pre">PackBEAM</span></code> tool</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-atomvm">Running AtomVM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#atomvm-program-syntax"><code class="docutils literal notranslate"><span class="pre">AtomVM</span></code> program syntax</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#core-apis">Core APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#standard-libraries">Standard Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spawning-processes">Spawning Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#console-output">Console Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logging">Logging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-logger-manager">The <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#writing-your-own-log-handler">Writing your own log handler</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#process-management">Process Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-apis">System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-time">System Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="#date-and-time">Date and Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stacktraces">StackTraces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-data-from-avm-files">Reading data from AVM files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-loading">Code Loading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#math">Math</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cryptographic-operations">Cryptographic Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#esp32-specific-apis">ESP32-specific APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#system-level-apis">System-Level APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-volatile-storage">Non-volatile Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restart-and-deep-sleep">Restart and Deep Sleep</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rtc-memory">RTC Memory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#peripherals">Peripherals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gpio">GPIO</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-handling">Interrupt Handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#i2c">I2C</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spi">SPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uart">UART</a></li>
<li class="toctree-l3"><a class="reference internal" href="#led-control">LED Control</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#protocols">Protocols</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#network-esp32-only">Network (ESP32 only)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sta-mode">STA mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ap-mode">AP mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sta-ap-mode">STA+AP mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sntp">SNTP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#udp">UDP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp">TCP</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#server-side-tcp">Server-side TCP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#client-side-tcp">Client-side TCP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="example-programs.html">Example Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="network-programming-guide.html">Network Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="build-instructions.html">Build Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="atomvm-internals.html">AtomVM Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="packbeam-format.html">Packbeam Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference-documentation.html">API Reference Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="CHANGELOG.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">AtomVM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Programmers Guide</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <!--
 Copyright 2021-2022 Fred Dushin <fred@dushin.net>

 SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
-->
<section id="programmers-guide">
<h1>Programmers Guide<a class="headerlink" href="#programmers-guide" title="Permalink to this heading"></a></h1>
<p>This guide is intended for programmers who develop applications targeted for AtomVM.</p>
<p>As an implementation of the Erlang virtual machine, AtomVM is designed to execute unmodified byte-code instructions compiled into BEAM files, either by the Erlang or Elixir compilers.  This allow developers to write programs in their BEAM programming language of choice, and to use the common Erlang community tool-chains specific to their language platform, and to then deploy those applications onto the various devices that AtomVM supports.</p>
<p>This document describes the development workflow when writing AtomVM applications, as well as a high-level overview of the various APIs that are supported by AtomVM.  With an understanding of this guide, you should be able to design, implement, and deploy applications onto a device running the AtomVM virtual machine.</p>
<section id="atomvm-features">
<h2>AtomVM Features<a class="headerlink" href="#atomvm-features" title="Permalink to this heading"></a></h2>
<p>Currently, AtomVM implements a strict subset of the BEAM instruction set.</p>
<p>A high level overview of the supported language features include:</p>
<ul class="simple">
<li><p>All the major Erlang types, including</p>
<ul>
<li><p>integers (with size limits)</p></li>
<li><p>floats</p></li>
<li><p>tuples</p></li>
<li><p>lists</p></li>
<li><p>binaries</p></li>
<li><p>maps</p></li>
</ul>
</li>
<li><p>support for many Erlang BIFs and guard expressions to support the above types</p></li>
<li><p>pattern matching (case statements, function clause heads, etc)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">catch</span> <span class="pre">...</span> <span class="pre">finally</span></code> constructs</p></li>
<li><p>anonymous functions</p></li>
<li><p>process <code class="docutils literal notranslate"><span class="pre">spawn</span></code> and <code class="docutils literal notranslate"><span class="pre">spawn_link</span></code></p></li>
<li><p>send (<code class="docutils literal notranslate"><span class="pre">!</span></code>) and <code class="docutils literal notranslate"><span class="pre">receive</span></code> messages</p></li>
<li><p>bit syntax (with some restrictions)</p></li>
<li><p>reference counted binaries</p></li>
<li><p>stacktraces</p></li>
<li><p>symmetric multi-processing (SMP)</p></li>
</ul>
<p>In addition, several features are supported specifically for integration with micro-controllers, including:</p>
<ul class="simple">
<li><p>Wifi networking (<code class="docutils literal notranslate"><span class="pre">network</span></code>)</p></li>
<li><p>UDP and TCP/IP support (<code class="docutils literal notranslate"><span class="pre">inet</span></code>, <code class="docutils literal notranslate"><span class="pre">gen_tcp</span></code> and <code class="docutils literal notranslate"><span class="pre">gen_udp</span></code>)</p></li>
<li><p>Peripheral and system support on micro-controllers, including</p>
<ul>
<li><p>GPIO, including pins reads, writes, and interrupts</p></li>
<li><p>I2C interface</p></li>
<li><p>SPI interface</p></li>
<li><p>UART interface</p></li>
<li><p>LEDC (PWM)</p></li>
<li><p>non-volatile storage (NVS)</p></li>
<li><p>RTC storage</p></li>
<li><p>deep sleep</p></li>
</ul>
</li>
</ul>
<section id="limitations">
<h3>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading"></a></h3>
<p>While the list of supported features is long and growing, the currently unsupported Erlang/OTP and BEAM features include (but are not limited to):</p>
<ul class="simple">
<li><p>Bignums.  Integer values are restricted to 64-bit values.</p></li>
<li><p>Bit Syntax.  While packing and unpacking of arbitrary (but less than 64-) bit values is support, packing and unpacking of integer values at the start or end of a binary, or bordering binary packing or extraction must align on 8-bit boundaries.  Arbitrary bit length binaries are not currently supported.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">epmd</span></code> and the <code class="docutils literal notranslate"><span class="pre">disterl</span></code> protocols are not supported.</p></li>
<li><p>There is no support for code hot swapping.</p></li>
<li><p>There is no support for a Read-Eval-Print-Loop. (REPL)</p></li>
<li><p>Numerous modules and functions from Erlang/OTP standard libraries (<code class="docutils literal notranslate"><span class="pre">kernel</span></code>, <code class="docutils literal notranslate"><span class="pre">stdlib</span></code>, <code class="docutils literal notranslate"><span class="pre">sasl</span></code>, etc) are not implemented.</p></li>
</ul>
<p>AtomVM bit syntax is restricted to alignment on 8-bit boundaries.  Little-endian and signed insertion and extraction of integer values is restricted to 8, 16, and 32-bit values.  Only unsigned big and little endian 64-bit values can be inserted into or extracted from binaries.</p>
<p>It is highly unlikely that an existing Erlang program targeted for Erlang/OTP will run unmodified on AtomVM.  And indeed, even as AtomVM matures and additional features are added, it is more likely than not that Erlang applications will need to targeted specifically for the AtomVM platform.  The intended target environment (small, cheap micro-controllers) differs enough from desktop or server-class systems in both scale and APIs that special care and attention is needed to target applications for such embedded environments.</p>
<p>That being said, many of the features of the BEAM are supported and provide a rich and compelling development environment for embedded devices, which Erlang and Elixir developers will find natural and productive.</p>
</section>
</section>
<section id="atomvm-development">
<h2>AtomVM Development<a class="headerlink" href="#atomvm-development" title="Permalink to this heading"></a></h2>
<p>This section describes the typical development environment and workflow most AtomVM developers are most likely to use.</p>
<section id="development-environment">
<h3>Development Environment<a class="headerlink" href="#development-environment" title="Permalink to this heading"></a></h3>
<p>In general, for most development purposes, you should be able to get away with an Erlang/OTP development environment, and for Elixir developers, and Elixir development environment.  For specific version requirements, see the <a class="reference internal" href="release-notes.html"><span class="std std-doc">Release Notes</span></a>.</p>
<p>We assume most development will take place on some UNIX-like environment (e.g., Linux, FreeBSD, or MacOS).  Consult your local package manager for installation of these development environments.</p>
<p>Developers will want to make use of common Erlang or Elixir development tools, such as <code class="docutils literal notranslate"><span class="pre">rebar3</span></code> for Erlang developers or <code class="docutils literal notranslate"><span class="pre">mix</span></code> for Elixir developers.</p>
<p>Developers will need to make use of some AtomVM tooling.  Fortunately, there are several choices for developers to use:</p>
<ol class="arabic simple">
<li><p>AtomVM <code class="docutils literal notranslate"><span class="pre">PackBEAM</span></code> executable (described below)</p></li>
<li><p><a class="reference external" href="https://github.com/atomvm/atomvm_rebar3_plugin"><code class="docutils literal notranslate"><span class="pre">atomvm_rebar3_plugin</span></code></a>, for Erlang development using <a class="reference external" href="https://rebar3.readme.io"><code class="docutils literal notranslate"><span class="pre">rebar3</span></code></a>.</p></li>
<li><p><a class="reference external" href="https://github.com/atomvm/ExAtomVM"><code class="docutils literal notranslate"><span class="pre">ExAtomVM</span></code></a> Mix plugin, Elixir development using <a class="reference external" href="https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html"><code class="docutils literal notranslate"><span class="pre">Mix</span></code></a>.</p></li>
</ol>
<p>Some testing can be performed on UNIX-like systems, using the <code class="docutils literal notranslate"><span class="pre">AtomVM</span></code> executable that is suitable for your development environment.  AtomVM applications that do not make use of platform-specific APIs are suitable for such tests.</p>
<p>Deployment and testing on micro-controllers is slightly more involved, as these platforms require additional hardware and software, described below.</p>
<section id="esp32-deployment-requirements">
<h4>ESP32 Deployment Requirements<a class="headerlink" href="#esp32-deployment-requirements" title="Permalink to this heading"></a></h4>
<p>In order to deploy AtomVM applications to and test on the ESP32 platform, developers will need:</p>
<ul class="simple">
<li><p>A computer running MacOS or Linux (Windows support is TBD);</p></li>
<li><p>An ESP32 module with a USB/UART connector (typically part of an ESP32 development board);</p></li>
<li><p>A USB cable capable of connecting the ESP32 module or board to your development machine (laptop or PC);</p></li>
<li><p>The <a class="reference external" href="https://github.com/espressif/esptool"><code class="docutils literal notranslate"><span class="pre">esptool</span></code></a> program, for flashing the AtomVM image and AtomVM programs;</p></li>
<li><p>(Optional, but recommended) A serial console program, such as <code class="docutils literal notranslate"><span class="pre">minicom</span></code> or <code class="docutils literal notranslate"><span class="pre">screen</span></code>, so that you can view console output from your AtomVM application.</p></li>
</ul>
</section>
<section id="stm32-deployment-requirements">
<h4>STM32 Deployment Requirements<a class="headerlink" href="#stm32-deployment-requirements" title="Permalink to this heading"></a></h4>
<p>TODO</p>
</section>
</section>
<section id="development-workflow">
<h3>Development Workflow<a class="headerlink" href="#development-workflow" title="Permalink to this heading"></a></h3>
<p>For the majority of users, AtomVM applications are written in the Erlang or Elixir programming language.  These applications are compiled to BEAM (<code class="docutils literal notranslate"><span class="pre">.beam</span></code>) files using standard Erlang or Elixir compiler tool chains (<code class="docutils literal notranslate"><span class="pre">erlc</span></code>, <code class="docutils literal notranslate"><span class="pre">rebar3</span></code>, <code class="docutils literal notranslate"><span class="pre">mix</span></code>, etc).  The generated BEAM files contain byte-code that can be executed by the Erlang/OTP runtime, or by the AtomVM virtual machine.</p>
<blockquote>
<div><p>Note.  In a small number of cases, it may be useful to write parts of an application in the C programming language, as AtomVM nifs or ports.  However, writing AtomVM nifs and ports is outside of the scope of this document.</p>
</div></blockquote>
<p>Once Erlang and/or Elixir files are compiled to BEAM files, AtomVM provides tooling for processing and aggregating BEAM files into AtomVM Packbeam (<code class="docutils literal notranslate"><span class="pre">.avm</span></code>) files, using AtomVM tooling, distributed as part of AtomVM, or as provided through the AtomVM community.</p>
<p>AtomVM packbeam files are the applications and libraries that run on the AtomVM virtual machine.  For micro-controller devices, they are “flashed” or uploaded to the device; for command-line use of AtomVM (e.g., on Linux, FreeBSD, or MacOS), they are supplied as the first parameter to the AtomVM command.</p>
<p>The following diagram illustrates the typical development workflow, starting from Erlang or Elixir source code, and resulting in a deployed Packbeam file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*.erl or *.ex                  *.beam
+-------+                   +-------+
|       |+                  |       |+
|       ||+                 |       ||+
|       |||     --------&gt;   |       |||
|       |||  Erlang/Elixir  |       |||
+-------+||     Compiler    +-------+||
 +-------+|                  +-------+|
  +-------+                   +-------+
     ^                           |
     |                           | packbeam
     |                           |
     |                           v
     |                       +-------+
     |                       |       |
     | test                  |       |
     | debug                 |       |
     | fix                   |       |
     |                       +-------+
     |                        app.avm
     |                           |
     |                           | flash/upload
     |                           |
     |                           v
     +-------------------- Micro-controller
                              device
</pre></div>
</div>
<p>The typical compile-test-debug cycle can be summarized in the following steps:</p>
<ol class="arabic simple">
<li><p>Deploy the AtomVM virtual machine to your device</p></li>
<li><p>Develop an AtomVM application in Erlang or Elixir</p>
<ol class="arabic simple">
<li><p>Write application</p></li>
<li><p>Deploy application to device</p></li>
<li><p>Test/Debug/Fix application</p></li>
<li><p>Repeat</p></li>
</ol>
</li>
</ol>
<p>Deployment of the AtomVM virtual machine and an AtomVM application currently require a USB serial connection.  There is currently no support for over-the-air (OTA) updates.</p>
<p>For more information about deploying the AtomVM image and AtomVM applications to your device, see the <a class="reference internal" href="getting-started-guide.html"><span class="std std-doc">Getting Started Guide</span></a></p>
</section>
</section>
<section id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this heading"></a></h2>
<p>An AtomVM application is a collection of BEAM files, aggregated into an AtomVM “Packbeam” (<code class="docutils literal notranslate"><span class="pre">.avm</span></code>) file, and typically deployed (flashed) to some device.  These BEAM files be be compiled from Erlang, Elixir, or any other language that targets the Erlang VM.</p>
<blockquote>
<div><p>Note.  The return value from the <code class="docutils literal notranslate"><span class="pre">start/0</span></code> function is ignored.</p>
</div></blockquote>
<p>Here, for example is one of the smallest AtomVM applications you can write:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
-module(myapp).

-export([start/0]).

start() -&gt;
    ok.
</pre></div>
</div>
<p>This particular application doesn’t do much, of course.  The application will start and immediately terminate, with a return value of <code class="docutils literal notranslate"><span class="pre">ok</span></code>.  Typical AtomVM applications will be more complex than this one, and the AVM file that contains the application BEAM files will be considerably larger and more complex than the above program.</p>
<p>Most applications will spawn processes, send and receive messages between processes, and
wait for certain conditions to apply before terminating, if they terminate at all.  For applications
that spawn processes and run forever, you may need to add an empty <code class="docutils literal notranslate"><span class="pre">receive</span> <span class="pre">...</span> <span class="pre">end</span></code> block, to
prevent the AtomVM from terminating prematurely, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
wait_forever() -&gt;
    receive X -&gt; X end.
</pre></div>
</div>
<section id="packbeam-files">
<h3>Packbeam files<a class="headerlink" href="#packbeam-files" title="Permalink to this heading"></a></h3>
<p>AtomVM applications are packaged into Packbeam (<code class="docutils literal notranslate"><span class="pre">.avm</span></code>) files, which contain collections of files, typically BEAM (<code class="docutils literal notranslate"><span class="pre">.beam</span></code>) files that have been generated by the Erlang or Elixir compiler.</p>
<p>At least one BEAM module in this file must contain an exported <code class="docutils literal notranslate"><span class="pre">start/0</span></code> function.  The first module in a Packbeam file that contain this function is the entry-point of your application and will be executed when the AtomVM virtual machine starts.</p>
<p>Not all files in a Packbeam need to be BEAM modules – you can embed any type of file in a Packbeam file, for consumption by your AtomVM application.</p>
<blockquote>
<div><p>Note.  The Packbeam format is described in more detail in the AtomVM <a class="reference internal" href="packbeam-format.html"><span class="std std-doc">PackBEAM format</span></a>.</p>
</div></blockquote>
<p>The AtomVM community has provided several tools for simplifying your experience, as a developer.  These tools allow you to use standard Erlang and Elixir tooling (such as <code class="docutils literal notranslate"><span class="pre">rebar3</span></code> and <code class="docutils literal notranslate"><span class="pre">mix</span></code>) to build Packbeam files and deploy then to your device of choice.</p>
</section>
<section id="packbeam-tool">
<h3><code class="docutils literal notranslate"><span class="pre">PackBEAM</span></code> tool<a class="headerlink" href="#packbeam-tool" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">PackBEAM</span></code> tool is a command-line application that can be used to create Packbeam files from a collection of input files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shell$ PackBEAM -h
Usage: PackBEAM [-h] [-l] &lt;avm-file&gt; [&lt;options&gt;]
    -h                                                Print this help menu.
    -i                                                Include file and line information.
    -l &lt;input-avm-file&gt;                               List the contents of an AVM file.
    [-a] &lt;output-avm-file&gt; &lt;input-beam-or-avm-file&gt;+  Create an AVM file (archive if -a specified).
</pre></div>
</div>
<p>To create a packbeam file, specify the name of the AVM file to created (by convention, ending in <code class="docutils literal notranslate"><span class="pre">.avm</span></code>), followed by a list of BEAM files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shell$ PackBEAM foo.avm path/to/foo.beam path/to/bar.beam
</pre></div>
</div>
<p>You can also specify another AVM file to include.  Thus, for example, to add to BEAM file to an existing AVM file, you might enter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shell$ PackBEAM foo.avm foo.avm path/to/gnu.beam
</pre></div>
</div>
<p>To list the contents of an AVM file, use the <code class="docutils literal notranslate"><span class="pre">-l</span></code> flag:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shell% PackBEAM -l foo.avm
foo.beam *
bar.beam
gnu.beam
</pre></div>
</div>
<p>Any BEAM files that export a <code class="docutils literal notranslate"><span class="pre">start/0</span></code> function will contain an asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) in the AVM file contents.</p>
</section>
<section id="running-atomvm">
<h3>Running AtomVM<a class="headerlink" href="#running-atomvm" title="Permalink to this heading"></a></h3>
<p>AtomVM is executed in different ways, depending on the platform.  On most microcontrollers (e.g., the ESP32), the VM starts when the device is powered on.  On UNIX platforms, the VM is started from the command-line using the <code class="docutils literal notranslate"><span class="pre">AtomVM</span></code> executable.</p>
<p>AtomVM will use the first module in the supplied AVM file that exports a <code class="docutils literal notranslate"><span class="pre">start/0</span></code> function as the entrypoint for the application.</p>
<section id="atomvm-program-syntax">
<h4><code class="docutils literal notranslate"><span class="pre">AtomVM</span></code> program syntax<a class="headerlink" href="#atomvm-program-syntax" title="Permalink to this heading"></a></h4>
<p>On UNIX platforms, you can specify a BEAM file or AVM file as the first argument to the executable, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>shell$ AtomVM foo.avm
</pre></div>
</div>
<blockquote>
<div><p>Note. If you start the <code class="docutils literal notranslate"><span class="pre">AtomVM</span></code> executable with a BEAM file, then the corresponding module may not make any calls to external function in other modules, with the exception of built-in functions and Nifs that are included in the VM.</p>
</div></blockquote>
</section>
</section>
</section>
<section id="core-apis">
<h2>Core APIs<a class="headerlink" href="#core-apis" title="Permalink to this heading"></a></h2>
<p>The AtomVM virtual machine provides a set of Erlang built-in functions (BIFs) and native functions (NIFs), as well as a collection of Erlang and Elixir libraries that can be used from your applications.</p>
<p>This section provides an overview of these APIs.  For more detailed information about specific APIs, please consult the <a class="reference internal" href="#./api-reference-documentation.md"><span class="xref myst">API reference documentation</span></a>.</p>
<section id="standard-libraries">
<h3>Standard Libraries<a class="headerlink" href="#standard-libraries" title="Permalink to this heading"></a></h3>
<p>AtomVM provides a limited implementations of standard library modules, including:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">base64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gen_server</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gen_statem</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">io</span></code> and <code class="docutils literal notranslate"><span class="pre">io_lib</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lists</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maps</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">proplists</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">supervisor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timer</span></code></p></li>
</ul>
<p>In addition AtomVM provides limited implementations of standard Elixir modules, including:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">List</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tuple</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Enum</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Kernel</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Module</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Process</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Console</span></code></p></li>
</ul>
<p>For detailed information about these functions, please consult the <a class="reference internal" href="#./api-reference-documentation.md"><span class="xref myst">API reference documentation</span></a>.  These modules provide a strict subset of functionality from their Erlang/OTP counterparts.  However, they aim to be API-compatible with the Erlang/OTP interfaces, at least for the subset of provided functionality.</p>
</section>
<section id="spawning-processes">
<h3>Spawning Processes<a class="headerlink" href="#spawning-processes" title="Permalink to this heading"></a></h3>
<p>AtomVM supports the actor concurrency model that is pioneered in the Erlang/OTP runtime.  As such, users can spawn processes, send messages to and receive message from processes, and can link or monitor processes to be notified if they have crashed.</p>
<p>To spawn a process using a defined or anonymous function, pass the function to the <code class="docutils literal notranslate"><span class="pre">spawn/1</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Pid = spawn(fun run_some_code/0),
</pre></div>
</div>
<p>The function you pass may admit closures, so for example you can pass variables defined outside of the scope of the function to the anonymous function to pass into <code class="docutils literal notranslate"><span class="pre">spawn/1</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Args = ...
Pid = spawn(fun() -&gt; run_some_code_with_args(Args) end),
</pre></div>
</div>
<p>Alternatively, you can pass a module, function name, and list of arguments to the <code class="docutils literal notranslate"><span class="pre">spawn/3</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Args = ...
Pid = spawn(?MODULE, run_some_code_with_args, [Args]),
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">spawn_opt/2,4</span></code> functions can be be used to spawn a function with additional options that control the behavior of the spawned processs, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Pid = spawn_opt(fun run_some_code/0, [{min_heap_size, 1342}]),
</pre></div>
</div>
<p>The options argument is a properties list containing optionally the following entries:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Default Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">min_heap_size</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>none</p></td>
<td><p>Minimum heap size of the process.  The heap will shrink no smaller than this size.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max_heap_size</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>unbounded</p></td>
<td><p>Maximum heap size of the process.  The heap will grow no larger than this size.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">link</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">boolean()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">false</span></code></p></td>
<td><p>Whether to link the spawned process to the spawning process.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">monitor</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">boolean()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">false</span></code></p></td>
<td><p>Whether to link the spawning process should monitor the spawned process.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="console-output">
<h3>Console Output<a class="headerlink" href="#console-output" title="Permalink to this heading"></a></h3>
<p>There are several mechanisms for writing data to the console.</p>
<p>For common debugging, many users will find <code class="docutils literal notranslate"><span class="pre">erlang:display/1</span></code> sufficient for debugging:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
erlang:display({foo, [{bar, tapas}]}).
</pre></div>
</div>
<p>The output parameter is any Erlang term, and a newline will be appended automatically.</p>
<p>Users may prefer using the <code class="docutils literal notranslate"><span class="pre">io:format/1,2</span></code> functions for more controlled output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
io:format(&quot;The ~p did a ~p~n&quot;, [friddle, frop]).
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">io_lib</span></code> module can be used to format string data, as well.</p>
<blockquote>
<div><p>Note. Formatting parameters are currently limited to <code class="docutils literal notranslate"><span class="pre">~p</span></code>, <code class="docutils literal notranslate"><span class="pre">~s</span></code>, and <code class="docutils literal notranslate"><span class="pre">~n</span></code>.</p>
</div></blockquote>
</section>
<section id="logging">
<h3>Logging<a class="headerlink" href="#logging" title="Permalink to this heading"></a></h3>
<p>AtomVM supports a subset of the OTP logging facility, allowing users to send log event to log handlers (by default, the console), and to install handlers that handle log events.</p>
<p>To log events, you are encouraged to use the logging macros from the OTP <code class="docutils literal notranslate"><span class="pre">kernel</span></code> application.  You can use these macros at compile time, and the generated code can be run in AtomVM.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
-include_lib(&quot;kernel/include/logger.hrl&quot;).
...
?LOG_NOTICE(&quot;Something happened that might require your attention: ~p&quot;, [TheThing])
</pre></div>
</div>
<p>By default, this will result in a message displayed on the console, with a timestamp, log level, PID of the process that initiated the log message, the module, function, and function arity, together with the supplied log message:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2023-07-04T18:34:56.387 [notice] &lt;0.1.0&gt; test_logger:test_default_logger/0 Something happened that might require your attention: ThatThingThatHappened
</pre></div>
</div>
<blockquote>
<div><p>Note that log messages need not (and generally should not) include newline separators (<code class="docutils literal notranslate"><span class="pre">~n</span></code>) in log format messages, unless necessary.</p>
</div></blockquote>
<p>Users may provide a format string, with an optional list of arguments.  Alternatively, users can provide a map encapsulating a “report” in lieu of a format string.  Reports provide a mechanism for supplying a set of structured data directly to log handlers (see below), without necessarily incurring the cost of formatting log messages.</p>
<p>As with OTP, the following ordered log levels (from high to low) are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">emergency</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">critical</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alert</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warning</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">notice</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug</span></code></p></li>
</ul>
<p>By default, the logging facility drops any messages below <code class="docutils literal notranslate"><span class="pre">notice</span></code> level.  To set the default log level for the logging subsystem, see the <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code> section, below.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">logger</span></code> interface directly to log messages at different levels, but in general, the OTP logging macros are encouraged, as log events generated using the OTP macros include additional metadata (such as the location of the log event) you do not otherwise get using the functions in the <code class="docutils literal notranslate"><span class="pre">logger</span></code> module.</p>
<p>For example, the expression</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>logger:notice(&quot;Something happened that might require your attention: ~p&quot;, [TheThing])
</pre></div>
</div>
<p>may seem similar to using the <code class="docutils literal notranslate"><span class="pre">?LOG_NOTICE</span></code> macro, but less contextual information will be included in the log event.</p>
<p>For more information about the OTP logging facility, see the Erlang/OTP <a class="reference external" href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html">Logging</a> chapter.</p>
<blockquote>
<div><p>Note.  AtomVM does not currently support programmatic configuration of the logging subsystem.  All changes to default behavior should be done via the AtomVM <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code> module (see below).</p>
</div></blockquote>
<section id="the-logger-manager">
<h4>The <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code><a class="headerlink" href="#the-logger-manager" title="Permalink to this heading"></a></h4>
<p>In order to use the <code class="docutils literal notranslate"><span class="pre">logger</span></code> interface, you will need to first start the AtomVM <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code> service.</p>
<blockquote>
<div><p>Note.  Future versions of AtomVM may automatically start the logging subsystem as part of a kernel application, but currently, this service must be managed manually.</p>
</div></blockquote>
<p>To start the <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code>, use the <code class="docutils literal notranslate"><span class="pre">logger_manager:start_link/1</span></code> function, passing in a configuration map for the logging subsystem.</p>
<p>For example, the default logging framework can be started via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
{ok, _Pid} = logger_manager:start_link(#{})
</pre></div>
</div>
<blockquote>
<div><p>Note.  The logger_manager is a registered process, so the returned Pid may be ignored.</p>
</div></blockquote>
<p>The configuration map supplied to the logger_manager may contain the following keys:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">log_level</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">log_level()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">notice</span></code></p></td>
<td><p>Primary log level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">logger</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">logger_config()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">{handler,</span> <span class="pre">default,</span> <span class="pre">logger_std_h,</span> <span class="pre">undefined}</span></code></p></td>
<td><p>Log configuration</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">module_level</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">module_level()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">undefined</span></code></p></td>
<td><p>Log level specific to a set of modules</p></td>
</tr>
</tbody>
</table>
<p>where <code class="docutils literal notranslate"><span class="pre">log_level()</span></code> is defined to be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-type log_level() :: emergency | critical | alert | error | warning | notice | info | debug.
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">logger_config()</span></code> is defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-type handler_id() :: default | atom().
-type handler_config() :: #{
    id =&gt; atom(),
    module =&gt; module(),
    level =&gt; logger:level() | all | none,
    config =&gt; term()
}.
-type logger_config() :: [
    {handler, default, undefined} |
    {handler, HandlerId :: handler_id(), Handler :: module(), HandlerConfig :: handler_config()} |
    {module_level, logger:level(), [module()]}
].
</pre></div>
</div>
<p>You can set the log level for all log handlers by setting the <code class="docutils literal notranslate"><span class="pre">log_level</span></code> in this configuration map.  Any messages that are logged at levels “higher” than or equal to the configured log level will be logged by all log handlers.</p>
<p>The standard logger (<code class="docutils literal notranslate"><span class="pre">logger_std_h</span></code>) is included by default, if no default logger is specified (and if the default logger is not disabled – see below).  The standard logger will output log events to the console.</p>
<p>You can specify multiple log handlers in the <code class="docutils literal notranslate"><span class="pre">logger</span></code> configuration.  If a log entry is allowed for a given log level, then each log handler will handle the log message.  For example, you might have a log handler that sends messages over the network to a syslog daemon, or you might have another handler that writes log messages to a file.</p>
<p>You can pass handler configuration int the <code class="docutils literal notranslate"><span class="pre">config</span></code> element of the <code class="docutils literal notranslate"><span class="pre">handler_config()</span></code> you specify when specifying a logger.  The value of the <code class="docutils literal notranslate"><span class="pre">config</span></code> element can be any term and is made available to log handlers when events are logged (see below).</p>
<p>If the tuple <code class="docutils literal notranslate"><span class="pre">{handler,</span> <span class="pre">default,</span> <span class="pre">undefined}</span></code> is included in the logger configuration, the default logger will be disabled.</p>
<p>At most one <code class="docutils literal notranslate"><span class="pre">default</span></code> logger can be specified.  If you want to replace the <code class="docutils literal notranslate"><span class="pre">default</span></code> logger (<code class="docutils literal notranslate"><span class="pre">logger_std_h</span></code>), then specify a logger with the handler id <code class="docutils literal notranslate"><span class="pre">default</span></code>.</p>
<p>You can specify different log levels for specific modules.  For example, if you want to set the default log level for all handlers to be <code class="docutils literal notranslate"><span class="pre">notice</span></code> or higher, you can set the log level for a given module to <code class="docutils literal notranslate"><span class="pre">info</span></code>, and all <code class="docutils literal notranslate"><span class="pre">info</span></code> and higher messages will be logged for that module or set of modules.  Conversely, you can “quiet” a module if it is particularly noisy by setting its level to something relatively high.</p>
<p>For more information about how to configure the logging subsystem, see the <a class="reference external" href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html#kernel-configuration-parameters">Kernel Configuration Parameters</a> section of the OTP Logging chapter.</p>
<p>You can stop the <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code> via the <code class="docutils literal notranslate"><span class="pre">logger_manager:stop/0</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = logger_manager:stop()
</pre></div>
</div>
</section>
<section id="writing-your-own-log-handler">
<h4>Writing your own log handler<a class="headerlink" href="#writing-your-own-log-handler" title="Permalink to this heading"></a></h4>
<p>Additional loggers can be enabled via handler specifications.  A handler module must implement and export the <code class="docutils literal notranslate"><span class="pre">log/2</span></code> function, which takes a log event and a term containing the configuration for the logger handler instance.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
-module(my_module).

-export([..., log/2, ...]).

log(LogEvent, HandlerConfig) -&gt;
    %% do something with the log event
    %% return value is ignored
</pre></div>
</div>
<p>You can specify this handler in the <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code> configuration (see above) via a stanza such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{handler, my_id, my_module, HandlerConfig}
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">LogEvent</span></code> is a map structure containing the following fields:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">timestamp</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>The time (in microseconds since the UNIX epoch) at which the log event was generated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">level</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">logger:level()</span></code></p></td>
<td><p>The log level with which the log event was generated</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pid</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pid()</span></code></p></td>
<td><p>The process id of the Erlang process in which the event was generated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">msg</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">string()</span> <span class="pre">|</span> <span class="pre">{string(),</span> <span class="pre">list()}</span></code></p></td>
<td><p>The message format and arguments passed when the event was generated</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">meta</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">map()</span></code></p></td>
<td><p>Metadata passed when the event was generated.</p></td>
</tr>
</tbody>
</table>
<p>If the log event was generated using a logging macro, then the <code class="docutils literal notranslate"><span class="pre">meta</span></code> map also contains a <code class="docutils literal notranslate"><span class="pre">location</span></code> field with the following fields:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">file</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">string()</span></code></p></td>
<td><p>The path of the file in which the event was generated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">line</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>The line number in the file in which the event was generated</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mfa</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">{module(),</span> <span class="pre">function_name(),</span> <span class="pre">arity()}</span></code></p></td>
<td><p>The MFA of the function in which the event was generated</p></td>
</tr>
</tbody>
</table>
<p>The handler config is a map structure containing the id and module of the handler.</p>
<p>an arbitrary term and is passed into the log handler via configuration of the <code class="docutils literal notranslate"><span class="pre">logger_manager</span></code> (see above).</p>
</section>
</section>
<section id="process-management">
<h3>Process Management<a class="headerlink" href="#process-management" title="Permalink to this heading"></a></h3>
<p>You can obtain a list of all processes in the system via <code class="docutils literal notranslate"><span class="pre">erlang:processes/0</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Pids = erlang:processes().
</pre></div>
</div>
<p>And for each process, you can get detailed process information via the <code class="docutils literal notranslate"><span class="pre">erlang:process_info/2</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
[io:format(&quot;Heap size for Pid ~p: ~p~n&quot;, [Pid, erlang:process_info(Pid, heap_size)]) || Pid &lt;- Pids].
</pre></div>
</div>
<p>The return value is a tuple containing the key passed into the <code class="docutils literal notranslate"><span class="pre">erlang:process_info/2</span></code> function and its associated value.</p>
<p>The currently supported keys are enumerated in the following table:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">heap_size</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>Number of terms (in machine words) used in the process heap</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">stack_size</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>Number of terms (in machine words) used in the process stack</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">message_queue_len</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>Number of unprocessed messages in the process mailbox</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">memory</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>Total number of bytes used by the process (estimate)</p></td>
</tr>
</tbody>
</table>
<p>See the <code class="docutils literal notranslate"><span class="pre">word_size</span></code> key in the <a class="reference internal" href="#System_APIs"><span class="xref myst">System APIs</span></a> section for information about how to find the number of bytes used in a machine word on the current platform.</p>
</section>
<section id="system-apis">
<h3>System APIs<a class="headerlink" href="#system-apis" title="Permalink to this heading"></a></h3>
<p>You can obtain system information about the AtomVM virtual machine via the <code class="docutils literal notranslate"><span class="pre">erlang:system_info/1</span></code> function, which takes an atom parameter designating the desired datum.  Allowable parameters include</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">process_count</span></code> The number of processes running in the system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_count</span></code> The number of ports running in the system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atom_count</span></code> The number of atoms allocated in the system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">word_size</span></code> The word size (in bytes) on the current platform (typically 4 or 8).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atomvm_version</span></code> The version of AtomVM currently running (as a binary).</p></li>
</ul>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
io:format(&quot;Atom Count: ~p~n&quot;, [erlang:system_info(atom_count)]).
</pre></div>
</div>
<blockquote>
<div><p>Note.  Additional platform-specific information is supported, depending on the platform type.  See below.</p>
</div></blockquote>
<p>Use the <code class="docutils literal notranslate"><span class="pre">atomvm:platform/0</span></code> to obtain the system platform on which your code is running.  The return value of this function is an atom who’s value will depend on the platform on which your application is running.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
case atomvm:platform() of
    esp32 -&gt;
        io:format(&quot;I am running on an ESP32!~n&quot;);
    stm32 -&gt;
        io:format(&quot;I am running on an STM32!~n&quot;);
    generic_unix -&gt;
        io:format(&quot;I am running on a UNIX box!~n&quot;)
end.
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">erlang:garbage_collect/0</span></code> or <code class="docutils literal notranslate"><span class="pre">erlang:garbage_collect/1</span></code> to force the AtomVM garbage collector to run on a give process.  Garbage collection will in general happen automatically when additional free space is needed and is rarely needed to be called explicitly.</p>
<p>The 0-arity version of this function will run the garbage collector on the currently executing process.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Pid = ... %% get a reference to some pid
ok = erlang:garbage_collect(Pid).
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">erlang:memory/1</span></code> function to obtain information about allocated memory.</p>
<p>Currently, AtomVM supports the following types:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">binary</span></code></p></td>
<td><p>Return the total amount of memory (in bytes) occupied by (reference counted) binaries</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Note.  Binary data small enough to be stored in the Erlang process heap are not counted in this measurement.</p>
</div></blockquote>
</section>
<section id="system-time">
<h3>System Time<a class="headerlink" href="#system-time" title="Permalink to this heading"></a></h3>
<p>AtomVM supports numerous function for accessing the current time on the device.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">erlang:timestamp/0</span></code> to get the current time since the UNIX epoch (Midnight, Jan 1, 1970, UTC), at microsecond granularity, expressed as a triple (mega-seconds, seconds, and micro-seconds):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
{MegaSecs, Secs, MicroSecs} = erlang:timestamp().
</pre></div>
</div>
<p>User <code class="docutils literal notranslate"><span class="pre">erlang:system_time/1</span></code> to obtain the seconds, milliseconds or microseconds since the UNIX epoch (Midnight, Jan 1, 1970, UTC):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Seconds = erlang:system_time(second).
MilliSeconds = erlang:system_time(millisecond).
MicroSeconds = erlang:system_time(microsecond).
</pre></div>
</div>
<p>User <code class="docutils literal notranslate"><span class="pre">erlang:monotonic_time/1</span></code> to obtain a (possibly not strictly) monotonically increasing time measurement.  Use the same time units to convert to seconds, milliseconds, or microseconds:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Seconds = erlang:monotonic_time(second).
MilliSeconds = erlang:monotonic_time(millisecond).
MicroSeconds = erlang:monotonic_time(microsecond).
</pre></div>
</div>
<blockquote>
<div><p>Note.  <code class="docutils literal notranslate"><span class="pre">erlang:monotonic_time/1</span></code> should not be used to calculate the wall clock time, but instead should be used by applications to compute time differences in a manner that is independent of the system time on the device, which might change, for example, due to NTP, leap seconds, or similar operations that may affect the wall time on the device.</p>
</div></blockquote>
<p>Use <code class="docutils literal notranslate"><span class="pre">erlang:universaltime/0</span></code> to get the current time at second resolution, to obtain the year, month, day, hour, minute, and second:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
{{Year, Month, Day}, {Hour, Minute, Second}} = erlang:universaltime().
</pre></div>
</div>
<blockquote>
<div><p>Note.  Setting the system time is done in a platform-specific manner.  For information about how to set system time on the ESP32, see the <a class="reference internal" href="network-programming-guide.html"><span class="std std-doc">Network Programming Guide</span></a>.</p>
</div></blockquote>
<p>To convert a time (in seconds, milliseconds, or microseconds from the UNIX epoch) to a date-time, use the <code class="docutils literal notranslate"><span class="pre">calendar:system_time_to_universal_time/2</span></code> function.  For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Milliseconds = ... %% get milliseconds from the UNIX epoch
{{Year, Month, Day}, {Hour, Minute, Second}} = calendar:system_time_to_universal_time(Milliseconds, millisecond).
</pre></div>
</div>
<p>Valid time units are <code class="docutils literal notranslate"><span class="pre">second</span></code>, <code class="docutils literal notranslate"><span class="pre">millisecond</span></code>, and <code class="docutils literal notranslate"><span class="pre">microsecond</span></code>.</p>
</section>
<section id="date-and-time">
<h3>Date and Time<a class="headerlink" href="#date-and-time" title="Permalink to this heading"></a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">datetime()</span></code> is a tuple containing a date and time, where a date is a tuple containing the year, month, and day (in the <a class="reference external" href="https://en.wikipedia.org/wiki/Gregorian_calendar">Gregorian</a> calendar), expressed as integers, and a time is an hour, minute, and second, also expressed in integers.</p>
<p>The following Erlang type specification enumerates this type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
-type year() :: integer().
-type month() :: 1..12.
-type day() :: 1..31.
-type date() :: {year(), month(), day()}.
-type gregorian_days() :: integer().
-type day_of_week() :: 1..7.
-type hour() :: 0..23.
-type minute() :: 0..59.
-type second() :: 0..59.
-type time() :: {hour(), minute(), second()}.
-type datetime() :: {date(), time()}.
</pre></div>
</div>
<p>Erlang/OTP uses the Christian epoch to count time units from year 0 in the Gregorian calendar.  The, for example, the value 0 in Gregorian seconds represents the date Jan 1, year 0, and midnight (UTC), or in Erlang terms, <code class="docutils literal notranslate"><span class="pre">{{0,</span> <span class="pre">1,</span> <span class="pre">1},</span> <span class="pre">{0,</span> <span class="pre">0,</span> <span class="pre">0}}</span></code>.</p>
<blockquote>
<div><p>Note.  AtomVM is currently limited to representing integers in at most 64 bits, with one bit representing the sign bit.  However, even with this limitation, AtomVM is able to resolve microsecond values in the Gregorian calendar for over 292,000 years, likely well past the likely lifetime of an AtomVM application (unless perhaps launched on a deep space probe).</p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">calendar</span></code> module provides useful functions for converting dates to Gregorian days, and date-times to Gregorian seconds.</p>
<p>To convert a <code class="docutils literal notranslate"><span class="pre">date()</span></code> to the number of days since January 1, year 0, use the <code class="docutils literal notranslate"><span class="pre">calendar:date_to_gregorian_days/1</span></code> function, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GregorianDays = calendar:date_to_gregorian_days({2023, 7, 23})
</pre></div>
</div>
<p>To convert a <code class="docutils literal notranslate"><span class="pre">datetime()</span></code> to convert the number of seconds since midnight January 1, year 0, use the <code class="docutils literal notranslate"><span class="pre">calendar:datetime_to_gregorian_seconds/1</span></code> function, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GregorianSeconds = calendar:datetime_to_gregorian_seconds({{2023, 7, 23}, {13, 31, 7}})
</pre></div>
</div>
<blockquote>
<div><p>Note.  The <code class="docutils literal notranslate"><span class="pre">calendar</span></code> module does not support year values before year <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</div></blockquote>
</section>
<section id="miscellaneous">
<h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this heading"></a></h3>
<p>Use <code class="docutils literal notranslate"><span class="pre">atomvm:random/0</span></code> to generate a random unsigned 32-bit integer in the range <code class="docutils literal notranslate"><span class="pre">0..4294967295</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
RandomInteger = atomvm:random().
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">atomvm:random_bytes/1</span></code> to return a randomly populated binary of a specified size:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
RandomBinary = erlang:random_bytes(32).
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">base64:encode/1</span></code> and <code class="docutils literal notranslate"><span class="pre">base64:decode/1</span></code> to encode to and decode from Base64 format.  The input value to these functions may be a binary or string.  The output value from these functions is an Erlang binary.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Encoded = base64:encode(&lt;&lt;&quot;foo&quot;&gt;&gt;).
&lt;&lt;&quot;foo&quot;&gt;&gt; = base64:decode(Encoded).
</pre></div>
</div>
<p>You can Use <code class="docutils literal notranslate"><span class="pre">base64:encode_to_string/1</span></code> and <code class="docutils literal notranslate"><span class="pre">base64:decode_to_string/1</span></code> to perform the same encoding, but to return values as Erlang list structures, instead of as binaries.</p>
</section>
<section id="stacktraces">
<h3>StackTraces<a class="headerlink" href="#stacktraces" title="Permalink to this heading"></a></h3>
<p>You can obtain information about the current state of a process via stacktraces, which provide information about the location of function calls (possibly including file names and line numbers) in your program.</p>
<p>Currently in AtomVM, stack traces can be obtained in one of following ways:</p>
<ul class="simple">
<li><p>via try-catch blocks</p></li>
<li><p>via catch blocks, when an error has been raised via the <code class="docutils literal notranslate"><span class="pre">error</span></code> Bif.</p></li>
</ul>
<blockquote>
<div><p>Note.  AtomVM does not support <code class="docutils literal notranslate"><span class="pre">erlang:get_stacktrace/0</span></code> which was deprecated in Erlang/OTP 21 and 22, stopped working in Erlang/OTP 23 and was removed in Erlang/OTP 24.  Support for accessing the current stacktrace via <code class="docutils literal notranslate"><span class="pre">erlang:process_info/2</span></code> may be added in the future.</p>
</div></blockquote>
<p>For example a stack trace can be bound to a variable in the catch clause in a try-catch block:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>try
    do_something()
catch
    _Class:_Error:Stacktrace -&gt;
        io:format(&quot;Stacktrace: ~p~n&quot;, [Stacktrace])
end
</pre></div>
</div>
<p>Alternatively, a stack trace can be bound to the result of a <code class="docutils literal notranslate"><span class="pre">catch</span></code> expression, but only when the error is raised by the <code class="docutils literal notranslate"><span class="pre">error</span></code> Bif.  For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;EXIT&#39;, {foo, Stacktrace}} = (catch error(foo)),
io:format(&quot;Stacktrace: ~p~n&quot;, [Stacktrace])
</pre></div>
</div>
<p>Stack traces are printed to the console in a crash report, for example, when a process dies unexpectedly.</p>
<p>Stacktrace data is represented as a list of tuples, each of which represents a stack “frame”.  Each tuple is of the form:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[{Module :: module(), Function :: atom(), Arity :: non_neg_integer(), AuxData :: aux_data()}]
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">aux_data()</span></code> is a (possibly empty) properties list containing the following elements:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[{file, File :: string(), line, Line :: pos_integer()}]
</pre></div>
</div>
<p>Stack frames are ordered from the frame “closest“ to the point of failure (the “top” of the stack) to the frame furthest from the point of failure (the “bottom” of the stack).</p>
<p>Stack frames will contain file and line information in the AuxData list if the BEAM files (typically embedded in AVM files) include &lt;&lt;“Line”&gt;&gt; chunks generated by the compiler.  Otherwise, the AuxData will be an empty list.</p>
<blockquote>
<div><p>Note.  Adding line information to BEAM files not only increases the size of BEAM files in storage, but calculation of file and line information can have a non-negligible impact on memory usage.  Memory-sensitive applications should consider not including line information in BEAM files.</p>
</div></blockquote>
<p>The PackBEAM tool does not include file and line information in the AVM files it creates, but file and line information can be included via a command line option.  For information about the PackBEAM too, see the <a class="reference internal" href="#Packbeam_tool"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">PackBEAM</span></code> tool</span></a>.</p>
</section>
<section id="reading-data-from-avm-files">
<h3>Reading data from AVM files<a class="headerlink" href="#reading-data-from-avm-files" title="Permalink to this heading"></a></h3>
<p>AVM files are generally packed BEAM files, but they can also contain non-BEAM files, such as plain text files, binary data, or even encoded Erlang terms.</p>
<p>Typically, these files are included from the <code class="docutils literal notranslate"><span class="pre">priv</span></code> directory in a build tree, for example, when using the <a class="reference external" href="https://github.com/atomvm/atomvm_rebar3_plugin"><code class="docutils literal notranslate"><span class="pre">atomvm_rebar3_plugin</span></code></a>, though the <a class="reference internal" href="packbeam-format.html"><span class="std std-doc"><code class="docutils literal notranslate"><span class="pre">PackBEAM</span></code></span></a> tool and the <a class="reference external" href="https://github.com/atomvm/atomvm_packbeam"><code class="docutils literal notranslate"><span class="pre">atomvm_packbeam</span></code></a> tool allow you to specify any location for files to include in AVM files.</p>
<p>By convention, these files obey the following path in an AVM file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;application-name&gt;/priv/&lt;file-path&gt;
</pre></div>
</div>
<p>For example, if you wanted to embed <code class="docutils literal notranslate"><span class="pre">my_file.txt</span></code> into your application AVM file (where your application name is, for example, <code class="docutils literal notranslate"><span class="pre">my_application</span></code>), you would use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_application/priv/my_file.txt
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">atomvm:read_priv/2</span></code> function can then be used to extract the contents of this file into a binary, e.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
MyFileBin = atomvm:read_priv(my_application, &lt;&lt;&quot;my_file.txt&quot;&gt;&gt;)
</pre></div>
</div>
<blockquote>
<div><p>Note. Embedded files may contain path separators, so for example <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&quot;my_files/my_file.txt&quot;&gt;&gt;</span></code> would be used if the AVM file embeds <code class="docutils literal notranslate"><span class="pre">my_file.txt</span></code> using the path <code class="docutils literal notranslate"><span class="pre">my_application/priv/my_files/my_file.txt</span></code></p>
</div></blockquote>
<p>For more information about how to embed files into AVM files, see the <a class="reference external" href="https://github.com/atomvm/atomvm_rebar3_plugin"><code class="docutils literal notranslate"><span class="pre">atomvm_rebar3_plugin</span></code></a>.</p>
</section>
<section id="code-loading">
<h3>Code Loading<a class="headerlink" href="#code-loading" title="Permalink to this heading"></a></h3>
<p>AtomVM provides a limited set of APIs for loading code and data embedded dynamically at runtime.</p>
<p>To load an AVM file from binary data, use the <code class="docutils literal notranslate"><span class="pre">atomvm:add_avm_pack_binary/2</span></code> function.  Supply a reference to the AVM data, together with a (possibly empty) list of options.  Specify a <code class="docutils literal notranslate"><span class="pre">name</span></code> option, whose value is an atom, if you wish to close the AVM data at a later point in the program.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
AVMData = ... %% load AVM data into memory as a binary
ok = atomvm:add_avm_pack_binary(AVMData, [{name, my_avm}])
</pre></div>
</div>
<p>You can also load AVM data from a file (on the <code class="docutils literal notranslate"><span class="pre">generic_unix</span></code> platform) or from a flash partition (on ESP32 platforms) using the <code class="docutils literal notranslate"><span class="pre">atomvm:add_avm_pack_file/2</span></code> function.  Specify a string (or binary) as the path to the AVM file, together with a list of options, such as <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = atomvm:add_avm_pack_file(&quot;/path/to/file.avm&quot;, [{name, my_avm}])
</pre></div>
</div>
<p>On <code class="docutils literal notranslate"><span class="pre">esp32</span></code> platforms, the partition name should be prefixed with the string <code class="docutils literal notranslate"><span class="pre">/dev/partition/by-name/</span></code>.  Thus, for example, if you specify <code class="docutils literal notranslate"><span class="pre">/dev/partition/by-name/main2.avm</span></code> as the partition, the ESP32 flash should contain a data partition with the name <code class="docutils literal notranslate"><span class="pre">main2.avm</span></code></p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = atomvm:add_avm_pack_file(&quot;/dev/partition/by-name/main2.avm&quot;, [])
</pre></div>
</div>
<p>To close a previous opened AVM by name, use the <code class="docutils literal notranslate"><span class="pre">atomvm:close_avm_pack/2</span></code> function.  Specify the name of the AVM pack used to add</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = atomvm:close_avm_pack(my_avm, [])
</pre></div>
</div>
<blockquote>
<div><p>Note.  Currently, the options parameter is ignored, so use the empty list (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) for foward compatibility.</p>
</div></blockquote>
<p>You can load an individual BEAM file using the <code class="docutils literal notranslate"><span class="pre">code:load_binary/3</span></code> function.  Specify the Module name (as an atom), as well as the BEAM data you have loaded into memory.</p>
<p>For Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
BEAMData = ... %% load BEAM data into memory as a binary
{module, Module} = code:load_binary(Module, Filename, BEAMData)
</pre></div>
</div>
<blockquote>
<div><p>Note.  The <code class="docutils literal notranslate"><span class="pre">Filename</span></code> parameter is currently ignored.</p>
</div></blockquote>
<p>You can load an individual BEAM file from the file system using the <code class="docutils literal notranslate"><span class="pre">code:load_abs/1</span></code> function.  Specify the path to the BEAM file.  This path should not include the <code class="docutils literal notranslate"><span class="pre">.beam</span></code> extension, as this extension will be added automatically.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{module, Module} = code:load_abs(&quot;/path/to/beam/file/without/beam/extension&quot;)
</pre></div>
</div>
<blockquote>
<div><p>Note.  This function is currently only supported on the <code class="docutils literal notranslate"><span class="pre">generic_unix</span></code> platform.</p>
</div></blockquote>
</section>
<section id="math">
<h3>Math<a class="headerlink" href="#math" title="Permalink to this heading"></a></h3>
<p>AtomVM supports the following standard functions from the OTP <code class="docutils literal notranslate"><span class="pre">math</span></code> module:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cos/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">acos/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">acosh/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">asin/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">asinh/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atan/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atan2/2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atanh/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ceil/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cosh/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exp/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">floor/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fmod/2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">log/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">log10/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">log2/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pow/2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sin/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sinh/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sqrt/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tan/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tanh/1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pi/0</span></code></p></li>
</ul>
<p>The input values for these functions may be <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">integer</span></code> types.  The return value is always a value of <code class="docutils literal notranslate"><span class="pre">float</span></code> type.</p>
<p>Input values that are out of range for the specific mathematical function or which otherwise are invalid or yield an invalid result (e.g., division by 0) will result in a <code class="docutils literal notranslate"><span class="pre">badarith</span></code> error.</p>
<blockquote>
<div><p>Note.  If the AtomVM virtual machine is built with floating point arithmetic support disabled, these functions will result in a <code class="docutils literal notranslate"><span class="pre">badarg</span></code> error.</p>
</div></blockquote>
</section>
<section id="cryptographic-operations">
<h3>Cryptographic Operations<a class="headerlink" href="#cryptographic-operations" title="Permalink to this heading"></a></h3>
<p>You can hash binary date using the <code class="docutils literal notranslate"><span class="pre">crypto:hash/2</span></code> function.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
crypto:hash(sha, [&lt;&lt;&quot;Some binary&quot;&gt;&gt;, $\s, &quot;data&quot;])
</pre></div>
</div>
<p>This function takes a hash algorithm, which may be one of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-type md_type() :: md5 | sha | sha224 | sha256 | sha384 | sha512.
</pre></div>
</div>
<p>and an IO list.  The output type is a binary, who’s length (in bytes) is dependent on the algorithm chosen:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm</p></th>
<th class="head"><p>Hash Length (bytes)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">md5</span></code></p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sha</span></code></p></td>
<td><p>20</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sha224</span></code></p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sha256</span></code></p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sha384</span></code></p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sha512</span></code></p></td>
<td><p>64</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Note.  The <code class="docutils literal notranslate"><span class="pre">crypto:hash/2</span></code> function is currently only supported on the ESP32 and generic UNIX platforms.</p>
</div></blockquote>
<p>You can also use the legacy <code class="docutils literal notranslate"><span class="pre">erlang:md5/1</span></code> function to compute the MD5 hash of an input binary.  The output is a fixed-length binary (16 bytes)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Hash = erlang:md5(&lt;&lt;foo&gt;&gt;).
</pre></div>
</div>
</section>
</section>
<section id="esp32-specific-apis">
<h2>ESP32-specific APIs<a class="headerlink" href="#esp32-specific-apis" title="Permalink to this heading"></a></h2>
<p>Certain APIs are specific to and only supported on the ESP32 platform.  This section describes these APIs.</p>
<section id="system-level-apis">
<h3>System-Level APIs<a class="headerlink" href="#system-level-apis" title="Permalink to this heading"></a></h3>
<p>As noted above, the <code class="docutils literal notranslate"><span class="pre">erlang:system_info/1</span></code> function can be used to obtain system-specific information about the platform on which your application is deployed.</p>
<p>You can request ESP32-specific information using using the following input atoms:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">esp_free_heap_size</span></code> Returns the available free space in the ESP32 heap.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_largest_free_block</span></code> Returns the size of the largest free continuous block in the ESP32 heap.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_get_minimum_free_size</span></code> Returns the smallest ever free space available in the ESP32 heap since boot, this will tell you how close you have come to running out of free memory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_chip_info</span></code> Returns map of the form <code class="docutils literal notranslate"><span class="pre">#{features</span> <span class="pre">:=</span> <span class="pre">Features,</span> <span class="pre">cores</span> <span class="pre">:=</span> <span class="pre">Cores,</span> <span class="pre">revision</span> <span class="pre">:=</span> <span class="pre">Revision,</span> <span class="pre">model</span> <span class="pre">:=</span> <span class="pre">Model}</span></code>, where <code class="docutils literal notranslate"><span class="pre">Features</span></code> is a list of features enabled in the chip, from among the following atoms: <code class="docutils literal notranslate"><span class="pre">[emb_flash,</span> <span class="pre">bgn,</span> <span class="pre">ble,</span> <span class="pre">bt]</span></code>; <code class="docutils literal notranslate"><span class="pre">Cores</span></code> is the number of CPU cores on the chip; <code class="docutils literal notranslate"><span class="pre">Revision</span></code> is the chip version; and <code class="docutils literal notranslate"><span class="pre">Model</span></code> is one of the following atoms: <code class="docutils literal notranslate"><span class="pre">esp32</span></code>, <code class="docutils literal notranslate"><span class="pre">esp32_s2</span></code>, <code class="docutils literal notranslate"><span class="pre">esp32_s3</span></code>, <code class="docutils literal notranslate"><span class="pre">esp32_c3</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_idf_version</span></code> Return the IDF SDK version, as a string.</p></li>
</ul>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
FreeHeapSize = erlang:system_info(esp_free_heap_size).
</pre></div>
</div>
</section>
<section id="non-volatile-storage">
<h3>Non-volatile Storage<a class="headerlink" href="#non-volatile-storage" title="Permalink to this heading"></a></h3>
<p>AtomVM provides functions for setting, retrieving, and deleting key-value data in binary form in non-volatile storage (NVS) on an ESP device.  Entries in NVS survive reboots of the ESP device, and can be used a limited “persistent store” for key-value data.</p>
<blockquote>
<div><p>Note.  NVS storage is limited in size, and NVS keys are restricted to 15 characters.  Try to avoid writing frequently to NVS storage, as the flash storage may degrade more rapidly with repeated writes to the medium.</p>
</div></blockquote>
<p>NVS entries are stored under a namespace and key, both of which are expressed as atoms.  AtomVM uses the namespace <code class="docutils literal notranslate"><span class="pre">atomvm</span></code> for entries under its control.  Applications may read from and write to the <code class="docutils literal notranslate"><span class="pre">atomvm</span></code> namespace, but they are strongly discouraged from doing so, except when explicitly stated otherwise.</p>
<p>To set a value in non-volatile storage, use the <code class="docutils literal notranslate"><span class="pre">esp:set_binary/3</span></code> function, and specify a namespace, key, and value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Namespace = &lt;&lt;&quot;my-namespace&quot;&gt;&gt;,
Key = &lt;&lt;&quot;my-key&quot;&gt;&gt;,
esp:set_binary(Namespace, Key, &lt;&lt;&quot;some-value&quot;&gt;&gt;).
</pre></div>
</div>
<p>To retrieve a value in non-volatile storage, use the <code class="docutils literal notranslate"><span class="pre">esp:get_binary/2</span></code> function, and specify a namespace and key.  You can optionally specify a default value (of any desired type), if an entry does not exist in non-volatile storage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Value = esp:get_binary(Namespace, Key, &lt;&lt;&quot;default-value&quot;&gt;&gt;).
</pre></div>
</div>
<p>To delete an entry, use the <code class="docutils literal notranslate"><span class="pre">esp:erase_key/2</span></code> function, and specify a namespace and key:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = esp:erase_key(Namespace, Key).
</pre></div>
</div>
<p>You can delete all entries in a namespace via the <code class="docutils literal notranslate"><span class="pre">esp:erase_all/1</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = esp:erase_all(Namespace).
</pre></div>
</div>
<p>Finally, you can delete all entries in all namespaces on the NVS partition via the <code class="docutils literal notranslate"><span class="pre">esp:reformat/0</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = esp:reformat().
</pre></div>
</div>
<p>Applications should use the <code class="docutils literal notranslate"><span class="pre">esp:reformat/0</span></code> function with caution, in case other applications are making using the non-volatile storage.</p>
<blockquote>
<div><p>Note.  NVS entries are currently stored in plaintext and are not encrypted.  Applications should exercise caution if sensitive security information, such as account passwords, are stored in NVS storage.</p>
</div></blockquote>
</section>
<section id="restart-and-deep-sleep">
<h3>Restart and Deep Sleep<a class="headerlink" href="#restart-and-deep-sleep" title="Permalink to this heading"></a></h3>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">esp:restart/0</span></code> function to immediately restart the ESP32 device.  This function does not return a value.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
esp:restart().
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">esp:reset_reason/0</span></code> function to obtain the reason for the ESP32 restart.  Possible values include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_unknown</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_poweron</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_ext</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_sw</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_panic</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_int_wdt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_task_wdt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_wdt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_deepsleep</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_brownout</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">esp_rst_sdio</span></code></p></li>
</ul>
<p>Use the <code class="docutils literal notranslate"><span class="pre">esp:deep_sleep/1</span></code> function to put the ESP device into deep sleep for a specified number of milliseconds.  Be sure to safely stop any critical processes running before this function is called, as it will cause an immediate shutdown of the device.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
esp:deep_sleep(60*1000).
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">esp:sleep_get_wakeup_cause/0</span></code> function to inspect the reason for a wakeup.  Possible return values include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_ext0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_ext1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_timer</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_touchpad</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_ulp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_gpio</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_uart</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_wifi</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_cocpu</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_cocpu_trag_trig</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep_wakeup_bt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">undefined</span></code> (no sleep wakeup)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code> (unknown other reason)</p></li>
</ul>
<p>The values matches the semantics of <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/release-v4.4/esp32/api-reference/system/sleep_modes.html#_CPPv426esp_sleep_get_wakeup_causev"><code class="docutils literal notranslate"><span class="pre">esp_sleep_get_wakeup_cause</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
case esp:sleep_get_wakeup_cause() of
    sleep_wakeup_timer -&gt;
        io:format(&quot;Woke up from a timer~n&quot;);
    sleep_wakeup_ext0 -&gt;
        io:format(&quot;Woke up from ext0~n&quot;);
    sleep_wakeup_ext1 -&gt;
        io:format(&quot;Woke up from ext1~n&quot;);
    _ -&gt;
        io:format(&quot;Woke up for some other reason~n&quot;)
end.
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">esp:sleep_enable_ext0_wakeup/2</span></code> and <code class="docutils literal notranslate"><span class="pre">esp:sleep_enable_ext1_wakeup</span></code> functions to configure ext0 and ext1 wakeup mechanisms. They follow the semantics of <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/release-v4.4/esp32/api-reference/system/sleep_modes.html#_CPPv428esp_sleep_enable_ext0_wakeup10gpio_num_ti"><code class="docutils literal notranslate"><span class="pre">esp_sleep_enable_ext0_wakeup</span></code></a> and <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/release-v4.4/esp32/api-reference/system/sleep_modes.html#_CPPv428esp_sleep_enable_ext1_wakeup8uint64_t28esp_sleep_ext1_wakeup_mode_t"><code class="docutils literal notranslate"><span class="pre">esp_sleep_enable_ext1_wakeup</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
-spec shutdown() -&gt; no_return().
shutdown() -&gt;
    % Configure wake up when GPIO 37 is set to low (M5StickC main button)
    ok = esp:sleep_enable_ext0_wakeup(37, 0),
    % Deep sleep for 1 hour
    esp:deep_sleep(60*60*1000).
</pre></div>
</div>
<section id="rtc-memory">
<h4>RTC Memory<a class="headerlink" href="#rtc-memory" title="Permalink to this heading"></a></h4>
<p>On ESP32 systems, you can use (slow) “real-time clock” memory to store data between deep sleeps.  This storage can be useful, for example, to store interim state data in your application.</p>
<blockquote>
<div><p>Note.  RTC memory is initialized if the device is reset.</p>
</div></blockquote>
<p>To store data in RTC slow memory, use the <code class="docutils literal notranslate"><span class="pre">esp:rtc_slow_set_binary/1</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
esp:rtc_slow_set_binary(&lt;&lt;&quot;some binary data&quot;&gt;&gt;)
</pre></div>
</div>
<p>To retrieve data in RTC slow memory, use the <code class="docutils literal notranslate"><span class="pre">esp:rtc_slow_get_binary/0</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Data = esp:rtc_slow_get_binary()
</pre></div>
</div>
<p>By default, RTC slow memory in AtomVM is limited to 4098 (4k) bytes.  This value can be modified at build time using an IDF SDK <code class="docutils literal notranslate"><span class="pre">KConfig</span></code> setting.  For  instructions about how to build AtomVM, see the AtomVM <a class="reference internal" href="#./build-instructions.html"><span class="xref myst">Build Instructions</span></a>.</p>
</section>
</section>
<section id="id1">
<h3>Miscellaneous<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">freq_hz</span></code> function can be used to retrieve the clock frequency of the chip.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">esp:freq_hz/0</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">esp:partition_list/0</span></code> function can be used to retrieve information about the paritions on an ESP32 flash.</p>
<p>The return type is a list of tuples, each of which contains the partition id (as a binary), partition type and sub-type (both of which are represented as integers), the start of the partition as an address along with its size, as well as a list of properties about the partition, as a properties list.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
PartitionList = esp:partition_list(),
lists:foreach(
    fun({PartitionId, PartitionType, PartitionSubtype, PartitionAddress, PartitionSize, PartitionProperties}) -&gt;
        %% ...
    end,
    PartitionList
)
</pre></div>
</div>
<blockquote>
<div><p>Note.  The partition properties are currently empty (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).</p>
</div></blockquote>
<p>For information about the encoding of partition types and sub-types, see the IDF SDK partition <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/v4.4.5/esp32/api-reference/storage/spi_flash.html?highlight=esp_partition_get#id13">type definitions</a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">esp:get_mac/1</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">esp:get_mac/1</span></code> function can be used to retrieve the network Media Access Control (<a class="reference external" href="https://en.wikipedia.org/wiki/MAC_address">MAC</a>) address for a given interface, <code class="docutils literal notranslate"><span class="pre">wifi_sta</span></code> or <code class="docutils literal notranslate"><span class="pre">wifi_softap</span></code>.  The return value is a 6-byte binary, in accordance with the <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_802">IEEE 802</a> family of specifications.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
MacAddress = esp:get_mac(wifi_sta)
</pre></div>
</div>
</section>
</section>
<section id="peripherals">
<h2>Peripherals<a class="headerlink" href="#peripherals" title="Permalink to this heading"></a></h2>
<p>The AtomVM virtual machine and libraries support APIs for interfacing with peripheral devices connected to the ESP32.  This section provides information about these APIs.</p>
<section id="gpio">
<h3>GPIO<a class="headerlink" href="#gpio" title="Permalink to this heading"></a></h3>
<p>You can read and write digital values on GPIO pins using the <code class="docutils literal notranslate"><span class="pre">gpio</span></code> module, using the <code class="docutils literal notranslate"><span class="pre">digital_read/1</span></code> and <code class="docutils literal notranslate"><span class="pre">digital_write/2</span></code> functions.  You must first set the direction of the pin using the <code class="docutils literal notranslate"><span class="pre">gpio:set_direction/2</span></code> function, using <code class="docutils literal notranslate"><span class="pre">input</span></code> or <code class="docutils literal notranslate"><span class="pre">output</span></code> as the direction parameter.</p>
<p>To read the value of a GPIO pin (<code class="docutils literal notranslate"><span class="pre">high</span></code> or <code class="docutils literal notranslate"><span class="pre">low</span></code>), use <code class="docutils literal notranslate"><span class="pre">gpio:digital_read/1</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Pin = 2,
gpio:set_direction(Pin, input),
case gpio:digital_read(Pin) of
    high -&gt;
        io:format(&quot;Pin ~p is high ~n&quot;, [Pin]);
    low -&gt;
        io:format(&quot;Pin ~p is low ~n&quot;, [Pin])
end.
</pre></div>
</div>
<p>To set the value of a GPIO pin (<code class="docutils literal notranslate"><span class="pre">high</span></code> or <code class="docutils literal notranslate"><span class="pre">low</span></code>), use <code class="docutils literal notranslate"><span class="pre">gpio:digital_write/2</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Pin = 2,
gpio:set_direction(Pin, output),
gpio:digital_write(Pin, low).
</pre></div>
</div>
<section id="interrupt-handling">
<h4>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this heading"></a></h4>
<p>You can get notified of changes in the state of a GPIO pin by using the <code class="docutils literal notranslate"><span class="pre">gpio:set_int/2</span></code> function.  This function takes a reference to a GPIO Pin and a trigger.  Allowable triggers are <code class="docutils literal notranslate"><span class="pre">rising</span></code>, <code class="docutils literal notranslate"><span class="pre">falling</span></code>, <code class="docutils literal notranslate"><span class="pre">both</span></code>, <code class="docutils literal notranslate"><span class="pre">low</span></code>, <code class="docutils literal notranslate"><span class="pre">high</span></code>, and <code class="docutils literal notranslate"><span class="pre">none</span></code> (to disable an interrupt).</p>
<p>When a trigger event occurs, such as a pin rising in voltage, a tuple will be delivered to the process containing the atom <code class="docutils literal notranslate"><span class="pre">gpio_interrupt</span></code> and the pin.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Pin = 2,
gpio:set_direction(Pin, input),
GPIO = gpio:open(),
ok = gpio:set_int(GPIO, Pin, rising),
receive
    {gpio_interrupt, Pin} -&gt;
        io:format(&quot;Pin ~p is rising ~n&quot;, [Pin])
end.
</pre></div>
</div>
<p>Interrupts can be removed by using the <code class="docutils literal notranslate"><span class="pre">gpio:remove_int/2</span></code> function.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">gpio:close/1</span></code> function to close the GPIO driver and free any resources in use by it, supplying a reference to a previously opened GPIO driver instance.  Any references to the closed GPIO instance are no longer valid after a successful call to this function, and all interrupts will be removed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = gpio:close(GPIO).
</pre></div>
</div>
<p>Since only one instance of the GPIO driver is allowed, you may also simply use <code class="docutils literal notranslate"><span class="pre">gpio:stop/0</span></code> to remove all interrupts, free the resouces, and close the GPIO driver port.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = gpio:stop().
</pre></div>
</div>
</section>
</section>
<section id="i2c">
<h3>I2C<a class="headerlink" href="#i2c" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">i2c</span></code> module encapsulates functionality associated with the 2-wire Inter-Integrated Circuit (I2C) interface.</p>
<blockquote>
<div><p>Note.  Information about the ESP32 I2C interface can be found in the IDF SDK <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/i2c.html">I2C Documentation</a>.</p>
</div></blockquote>
<p>The AtomVM I2C implementation uses the AtomVM Port mechanism and must be initialized using the <code class="docutils literal notranslate"><span class="pre">i2c:open/1</span></code> function.  The single parameter contains a properties list, with the following elements:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">scl_io_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>I2C clock pin (SCL)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sda_io_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>I2C data pin (SDA)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">i2c_clock_hz</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>I2C clock frequency (in hertz)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i2c_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">..</span> <span class="pre">I2C_NUM_MAX</span> <span class="pre">-</span> <span class="pre">1</span></code></p></td>
<td><p>no (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p></td>
<td><p>I2C port number.  <code class="docutils literal notranslate"><span class="pre">I2C_NUM_MAX</span></code> is defined by the device SDK.  On ESP32, this value is 1.</p></td>
</tr>
</tbody>
</table>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
I2C = i2c:open([
    {scl_io_num, 21}, {sda_io_num, 22}, {i2c_clock_hz, 40000}
])
</pre></div>
</div>
<p>Once the port is opened, you can use the returned <code class="docutils literal notranslate"><span class="pre">I2C</span></code> instance to read and write bytes to the attached device.</p>
<p>Both read and write operations require the I2C bus address from which data is read or to which data is written.  A devices address is typically hard-wired for the specific device type, or in some cases may be changed by the addition or removal of a resistor.</p>
<p>In addition, you may optionally specify a register to read from or write to, as some devices require specification of a register value.  Consult your device’s data sheet for more information and the device’s I2C bus address and registers, if applicable.</p>
<p>There are two patterns for writing data to an I2C device:</p>
<ol class="arabic simple">
<li><p>Queuing <code class="docutils literal notranslate"><span class="pre">i2c:qwrite_bytes/2,3</span></code> write operations between calls to <code class="docutils literal notranslate"><span class="pre">i2c:begin_transmission/1</span></code> and <code class="docutils literal notranslate"><span class="pre">i2c:end_transmission/1</span></code>.  In this case, write operations are queued locally and dispatched to the target device when the <code class="docutils literal notranslate"><span class="pre">i2c:end_transmission/1</span></code> operation is called;</p></li>
<li><p>Writing a byte or sequence of bytes in one <code class="docutils literal notranslate"><span class="pre">i2c:write_bytes/2,3</span></code> operation.</p></li>
</ol>
<p>The choice of which pattern to use will depend on the device being communicated with.  For example, some devices require a sequence of write operations to be queued and written in one atomic write, in which case the first pattern is appropriate.  E.g.,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = i2c:begin_transmission(I2C),
ok = i2c:qwrite_bytes(I2C, DeviceAddress, Register1, &lt;&lt;&quot;some sequence of bytes&quot;&gt;&gt;),
ok = i2c:qwrite_bytes(I2C, DeviceAddress, Register2, &lt;&lt;&quot;some other of bytes&quot;&gt;&gt;),
ok = i2c:end_transmission(I2C),
</pre></div>
</div>
<p>In other cases, you may just need to write a byte or sequence of bytes in one operation to the device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = i2c:write_bytes(I2C, DeviceAddress, Register1, &lt;&lt;&quot;write it all in one go&quot;&gt;&gt;),
</pre></div>
</div>
<p>Reading bytes is more straightforward.  Simply use <code class="docutils literal notranslate"><span class="pre">i2c:read_bytes/3,4</span></code>, specifying the port instance, device address, optionally a register, and the number of bytes to read:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
{ok, BinaryData} = i2c:read_bytes(I2C, DeviceAddress, Register, Len)
</pre></div>
</div>
<p>To close the I2C driver and free any resources in use by it, use the <code class="docutils literal notranslate"><span class="pre">i2c:close/1</span></code> function, supplying a reference to the I2C driver instance created via <code class="docutils literal notranslate"><span class="pre">i2c:open/1</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = i2c:close(I2C)
</pre></div>
</div>
<p>Once the I2C driver is closed, any calls to <code class="docutils literal notranslate"><span class="pre">i2c</span></code> functions using a reference to the I2C driver instance should return with the value <code class="docutils literal notranslate"><span class="pre">{error,</span> <span class="pre">noproc}</span></code>.</p>
</section>
<section id="spi">
<h3>SPI<a class="headerlink" href="#spi" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">spi</span></code> module encapsulates functionality associated with the 4-wire Serial Peripheral Interface (SPI) in leader mode.</p>
<blockquote>
<div><p>Note.  Information about the ESP32 SPI leader mode interface can be found in the IDF SDK <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/spi_master.html">SPI Documentation</a>.</p>
</div></blockquote>
<p>The AtomVM SPI implementation uses the AtomVM Port mechanism and must be initialized using the <code class="docutils literal notranslate"><span class="pre">spi:open/1</span></code> function.  The single parameter to this function is a properties list containing two elements:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bus_config</span></code> – a properties list containing entries for the SPI bus</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device_config</span></code> – a properties list containing entries for each device attached to the SPI Bus</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">bus_config</span></code> properties list contains the following entries:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">miso_io_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>SPI leader-in, follower-out pin (MOSI)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mosi_io_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>SPI leader-out, follower-in pin (MISO)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sclk_io_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>SPI clock pin (SCLK)</p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">device_config</span></code> entry is a properties list containing entries for each device attached to the SPI Bus.  Each entry in this list contains the user-selected name (as an atom) of the device, followed by configuration for the named device.</p>
<p>Each device configuration is a properties list containing the following entries:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">spi_clock_hz</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>SPI clock frequency (in hertz)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mode</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0..3</span></code></p></td>
<td><p>yes</p></td>
<td><p>SPI mode, indicating clock polarity (<code class="docutils literal notranslate"><span class="pre">CPOL</span></code>) and clock phase (<code class="docutils literal notranslate"><span class="pre">CPHA</span></code>).  Consult the SPI specification and data sheet for your device, for more information about how to control the behavior of the SPI clock.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">spi_cs_io_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>yes</p></td>
<td><p>SPI chip select pin (CS)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">address_len_bits</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0..64</span></code></p></td>
<td><p>yes</p></td>
<td><p>number of bits in the address field of a read/write operation (for example, 8, if the transaction address field is a single byte)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">command_len_bits</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0..16</span></code></p></td>
<td><p>default: 0</p></td>
<td><p>number of bits in the command field of a read/write operation (for example, 8, if the transaction command field is a single byte)</p></td>
</tr>
</tbody>
</table>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
SPIConfig = [
    {bus_config, [
        {miso_io_num, 19},
        {mosi_io_num, 27},
        {sclk_io_num, 5}
    ]},
    {device_config, [
        {my_device_1, [
            {spi_clock_hz, 1000000},
            {mode, 0},
            {spi_cs_io_num, 18},
            {address_len_bits, 8}
        ]}
        {my_device_2, [
            {spi_clock_hz, 1000000},
            {mode, 0},
            {spi_cs_io_num, 15},
            {address_len_bits, 8}
        ]}
    ]}
],
SPI = spi:open(SPIConfig),
...
</pre></div>
</div>
<p>In the above example, there are two SPI devices, one using pin 18 chip select (named <code class="docutils literal notranslate"><span class="pre">my_device_1</span></code>), and once using pin 15 chip select (named <code class="docutils literal notranslate"><span class="pre">my_device_2</span></code>).</p>
<p>Once the port is opened, you can use the returned <code class="docutils literal notranslate"><span class="pre">SPI</span></code> instance, along with the selected device name, to read and write bytes to the attached device.</p>
<p>To read a byte at a given address on the device, use the <code class="docutils literal notranslate"><span class="pre">spi:read_at/4</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
{ok, Byte} = spi:read_at(SPI, DeviceName, Address, 8)
</pre></div>
</div>
<p>To write a byte at a given address on the device, use the <code class="docutils literal notranslate"><span class="pre">spi_write_at/5</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
write_at(SPI, DeviceName, Address, 8, Byte)
</pre></div>
</div>
<blockquote>
<div><p>Note.  The <code class="docutils literal notranslate"><span class="pre">spi:write_at/5</span></code> takes integer values as inputs and the <code class="docutils literal notranslate"><span class="pre">spi:read_at/4</span></code> returns integer values. You may read and write up to 32-bit integer values via these functions.</p>
</div></blockquote>
<p>Consult your local device data sheet for information about various device addresses to read from or write to, and their semantics.</p>
<p>The above functions are optimized for small reads and writes to an SPI device, typically one byte at a time.</p>
<p>The SPI interface also supports a more generic way to read and write from an SPI device, supporting arbitrary-length reads and writes, as well as a number of different “phases” of writes, per the SPI specification.</p>
<p>These phases include:</p>
<ul class="simple">
<li><p>Command phase – write of an up-to 16-bit command to the SPI device</p></li>
<li><p>Address Phase – write of an up-to 64-bit address to the SPI device</p></li>
<li><p>Data Phase – read or write of an arbitrary amount of of data to and from the device.</p></li>
</ul>
<p>Any one of these phases may be included or omitted in any given SPI transaction.</p>
<p>In order to achieve this level of flexibility, these functions allow users to specify the SPI transaction through a map structure, which includes fields that specify the behavior of an SPI transaction.</p>
<p>The following table enumerates the permissible fields in this structure:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">command</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code> (16-bit)</p></td>
<td><p>(Optional) SPI command.  The low-order <code class="docutils literal notranslate"><span class="pre">command_len_bits</span></code> are written to the device.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">address</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code> (64-bit)</p></td>
<td><p>(Optional) Device address.  The low-order <code class="docutils literal notranslate"><span class="pre">address_len_bits</span></code> are written to the device.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">write_data</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">binary()</span></code></p></td>
<td><p>(Optional) Data to write</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">write_bits</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>Number of bits to write from `write_data’.  If not included,then all bits will be written.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">read_bits</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>Number of bits to read from the SPI device.  If not included, then the same number of bits will be read as were written.</p></td>
</tr>
</tbody>
</table>
<p>To write a blob of data to the SPI device, for example, you would use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>WriteData = &lt;&lt;&quot;some binary data&quot;&gt;&gt;,
ok = spi:write(SPI, DeviceName, #{write_data =&gt; WriteData})
</pre></div>
</div>
<p>To write and simultaneously read back a blob of data to the SPI device, you would use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{ok, ReadData} = spi:write_read(SPI, DeviceName, #{write_data =&gt; WriteData})
</pre></div>
</div>
<p>The size of the returned data is the same as the size of the written data, unless otherwise specified by the <code class="docutils literal notranslate"><span class="pre">read_bits</span></code> field.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">spi:close/1</span></code> function to close the SPI driver and free any resources in use by it, supplying a reference to a previously opened SPI driver instance.  Any references to the closed SPI instance are no longer valid after a successful call to this function.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = spi:close(SPI).
</pre></div>
</div>
</section>
<section id="uart">
<h3>UART<a class="headerlink" href="#uart" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">uart</span></code> module encapsulates functionality associated with the Universal Asynchronous Receiver/Transmitter (UART) interface supported on ESP32 devices.  Some devices, such as NMEA GPS receivers, make use of this interface for communicating with an ESP32.</p>
<blockquote>
<div><p>Note.  Information about the ESP32 UART interface can be found in the IDF SDK <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/uart.html">UART Documentation</a>.</p>
</div></blockquote>
<p>The AtomVM UART implementation uses the AtomVM Port mechanism and must be initialized using the <code class="docutils literal notranslate"><span class="pre">uart:open/2</span></code> function.</p>
<p>The first parameter indicates the ESP32 UART hardware interface.  Legal values are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;UART0&quot; | &quot;UART1&quot; | &quot;UART2&quot;
</pre></div>
</div>
<p>The selection of the hardware interface dictates the default RX and TX pins on the ESP32:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Port</p></th>
<th class="head"><p>RX pin</p></th>
<th class="head"><p>TX pin</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UART0</span></code></p></td>
<td><p>GPIO_3</p></td>
<td><p>GPIO_1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UART1</span></code></p></td>
<td><p>GPIO_9</p></td>
<td><p>GPIO_10</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UART2</span></code></p></td>
<td><p>GPIO_16</p></td>
<td><p>GPIO_17</p></td>
</tr>
</tbody>
</table>
<p>The second parameter is a properties list, containing the following elements:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Default Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">speed</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer()</span></code></p></td>
<td><p>no</p></td>
<td><p>115200</p></td>
<td><p>UART baud rate (bits/sec)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">data_bits</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">|</span> <span class="pre">6</span> <span class="pre">|</span> <span class="pre">7</span> <span class="pre">|</span> <span class="pre">8</span></code></p></td>
<td><p>no</p></td>
<td><p>8</p></td>
<td><p>UART data bits</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">stop_bits</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">|</span> <span class="pre">2</span></code></p></td>
<td><p>no</p></td>
<td><p>1</p></td>
<td><p>UART stop bits</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">flow_control</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">hardware</span> <span class="pre">|</span> <span class="pre">software</span> <span class="pre">|</span> <span class="pre">none</span></code></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">none</span></code></p></td>
<td><p>Flow control</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">parity</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">even</span> <span class="pre">|</span> <span class="pre">odd</span> <span class="pre">|</span> <span class="pre">none</span></code></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">none</span></code></p></td>
<td><p>UART parity check</p></td>
</tr>
</tbody>
</table>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
UART = uart:open(&quot;UART0&quot;, [{speed, 9600}])
</pre></div>
</div>
<p>Once the port is opened, you can use the returned <code class="docutils literal notranslate"><span class="pre">UART</span></code> instance to read and write bytes to the attached device.</p>
<p>To read data from the UART channel, use the <code class="docutils literal notranslate"><span class="pre">uart:read/1</span></code> function.  The return value from this function is a binary:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Bin = uart:read(UART)
</pre></div>
</div>
<p>To write data to the UART channel, use the <code class="docutils literal notranslate"><span class="pre">uart_write/2</span></code> function.  The input data is any Erlang I/O list:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
uart:write(UART, [&lt;&lt;&quot;any&quot;&gt;&gt;, $d, $a, $t, $a, &quot;goes&quot;, &lt;&lt;&quot;here&quot;&gt;&gt;])
</pre></div>
</div>
<p>Consult your local device data sheet for information about the format of data to be read from or written to the UART channel.</p>
<p>To close the UART driver and free any resources in use by it, use the <code class="docutils literal notranslate"><span class="pre">uart:close/1</span></code> function, supplying a reference to the UART driver instance created via <code class="docutils literal notranslate"><span class="pre">uart:open/2</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
ok = uart:close(UART)
</pre></div>
</div>
<p>Once the UART driver is closed, any calls to <code class="docutils literal notranslate"><span class="pre">uart</span></code> functions using a reference to the UART driver instance should return with the value <code class="docutils literal notranslate"><span class="pre">{error,</span> <span class="pre">noproc}</span></code>.</p>
</section>
<section id="led-control">
<h3>LED Control<a class="headerlink" href="#led-control" title="Permalink to this heading"></a></h3>
<p>The LED Control API can be used to drive LEDs, as well as generate PWM signals on GPIO pins.</p>
<p>The LEDC API is encapsulated in the <code class="docutils literal notranslate"><span class="pre">ledc</span></code> module and is a direct translation of the IDF SDK <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/ledc.html">LEDC API</a>, with a natural mapping into Erlang.  This API is intended for users with complex use-cases, and who require low-level access to the LEDC APIs.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ledc.hrl</span></code> module should be used for common modes, channels, duty cycle resolutions, and so forth.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
-include(&quot;ledc.hrl&quot;).

...

%% create a 5khz timer
SpeedMode = ?LEDC_HIGH_SPEED_MODE,
Channel = ?LEDC_CHANNEL_0,
ledc:timer_config([
    {duty_resolution, ?LEDC_TIMER_13_BIT},
    {freq_hz, 5000},
    {speed_mode, ?LEDC_HIGH_SPEED_MODE},
    {timer_num, ?LEDC_TIMER_0}
]).

%% bind pin 2 to this timer in a channel
ledc:channel_config([
    {channel, Channel},
    {duty, 0},
    {gpio_num, 2},
    {speed_mode, ?LEDC_HIGH_SPEED_MODE},
    {hpoint, 0},
    {timer_sel, ?LEDC_TIMER_0}
]).

%% set the duty cycle to 0, and fade up to 16000 over 5 seconds
ledc:set_duty(SpeedMode, Channel, 0).
ledc:update_duty(SpeedMode, Channel).
TargetDuty = 16000.
FadeMs = 5000.
ok = ledc:set_fade_with_time(SpeedMode, Channel, TargetDuty, FadeMs).
</pre></div>
</div>
</section>
</section>
<section id="protocols">
<h2>Protocols<a class="headerlink" href="#protocols" title="Permalink to this heading"></a></h2>
<p>AtomVM supports network programming on devices that support it, specifically the ESP32 platform, with its built-in support for WIFI networking, and of course on the UNIX platform.</p>
<p>This section describes the network programming APIs available on AtomVM.</p>
<section id="network-esp32-only">
<h3>Network (ESP32 only)<a class="headerlink" href="#network-esp32-only" title="Permalink to this heading"></a></h3>
<p>The ESP32 supports WiFi connectivity as part of the built-in WiFi and Bluetooth radio (and in most modules, an integrated antenna).  The WIFI radio on an ESP32 can operate in several modes:</p>
<ul class="simple">
<li><p>STA (Station) mode, whereby it acts as a member of an existing WiFi network;</p></li>
<li><p>AP (Access Point) mode, whereby the ESP32 acts as an access point for other devices; or</p></li>
<li><p>AP+STA mode, whereby the ESP32 behaves both as a member of an existing WiFi network and as an access point for other devices.</p></li>
</ul>
<p>AtomVM supports these modes of operation via the <code class="docutils literal notranslate"><span class="pre">network</span></code> module, which is used to initialize the network and allow applications to respond to events within the network, such as a network disconnect or reconnect, or a connection to the ESP32 from another device.</p>
<blockquote>
<div><p>Note. Establishment and maintenance of network connections on roaming devices is a complex and subtle art, and the AtomVM <code class="docutils literal notranslate"><span class="pre">network</span></code> module is designed to accommodate as many IoT scenarios as possible.  This section of the programmer’s guide is deliberately brief and only addresses the most basic scenarios.  For a more detailed explanation of the AtomVM <code class="docutils literal notranslate"><span class="pre">network</span></code> module and its many use-cases, please refer to the <a class="reference internal" href="network-programming-guide.html"><span class="std std-doc">AtomVM Network Programming Guide</span></a>.</p>
</div></blockquote>
<section id="sta-mode">
<h4>STA mode<a class="headerlink" href="#sta-mode" title="Permalink to this heading"></a></h4>
<p>To connect your ESP32 to an existing WiFi network, use the <code class="docutils literal notranslate"><span class="pre">network:wait_for_sta/1,2</span></code> convenience function, which abstracts away some of the more complex details of ESP32 STA mode.</p>
<p>This function takes a station mode configuration, as a properties list, and optionally a timeout (in milliseconds) before connecting to the network should fail.  The default timeout, if unspecified, is 15 seconds.</p>
<p>The station mode configuration supports the following options:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Default Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ssid</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">string()</span> <span class="pre">|</span> <span class="pre">binary()</span></code></p></td>
<td><p>yes</p></td>
<td><p>-</p></td>
<td><p>WiFi AP SSID</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">psk</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">string()</span> <span class="pre">|</span> <span class="pre">binary()</span></code></p></td>
<td><p>yes, if network is encrypted</p></td>
<td><p>-</p></td>
<td><p>WiFi AP password</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dhcp_hostname</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">string()</span> <span class="pre">|</span> <span class="pre">binary()</span></code></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">atomvm-&lt;MAC&gt;</span></code> where <code class="docutils literal notranslate"><span class="pre">&lt;MAC&gt;</span></code> is the factory-assigned MAC-address of the device</p></td>
<td><p>DHCP hostname for the connecting device</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Note.  The WiFi network to which you are connecting must support DHCP and IPv4.  IPv6 addressing is not yet supported on AtomVM.</p>
</div></blockquote>
<p>If the ESP32 device connects to the specified network successfully, the device’s assigned address, netmask, and gateway address will be returned in an <code class="docutils literal notranslate"><span class="pre">{ok,</span> <span class="pre">...}</span></code> tuple; otherwise, an error is returned.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Config = [
    {ssid, &lt;&lt;&quot;myssid&quot;&gt;&gt;},
    {psk,  &lt;&lt;&quot;mypsk&quot;&gt;&gt;},
    {dhcp_hostname, &lt;&lt;&quot;mydevice&quot;&gt;&gt;}
],
case network:wait_for_sta(Config, 15000) of
    {ok, {Address, _Netmask, _Gateway}} -&gt;
        io:format(&quot;Acquired IP address: ~p~n&quot;, [Address]);
    {error, Reason} -&gt;
        io:format(&quot;Network initialization failed: ~p~n&quot;, [Reason])
end
</pre></div>
</div>
<p>Once connected to a WiFi network, you may begin TCP or UDP networking, as described in more detail below.</p>
<p>For information about how to handle disconnections and reconnections to a WiFi network, see the <a class="reference internal" href="network-programming-guide.html"><span class="std std-doc">AtomVM Network Programming Guide</span></a>.</p>
</section>
<section id="ap-mode">
<h4>AP mode<a class="headerlink" href="#ap-mode" title="Permalink to this heading"></a></h4>
<p>To turn your ESP32 into an access point for other devices, you can use the <code class="docutils literal notranslate"><span class="pre">network:wait_for_ap/1,2</span></code> convenience function, which abstracts away some of the more complex details of ESP32 AP mode.  When the network is started, the ESP32 device will assign itself the <code class="docutils literal notranslate"><span class="pre">192.168.4.1</span></code> address.  Any devices that connect to the ESP32 will take addresses in the <code class="docutils literal notranslate"><span class="pre">192.168.4/24</span></code> network.</p>
<p>This function takes an access point mode configuration, as a properties list, and optionally a timeout (in milliseconds) before starting the network should fail.  The default timeout, if unspecified, is 15 seconds.</p>
<p>The access point mode configuration supports the following options:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Default Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ssid</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">string()</span> <span class="pre">|</span> <span class="pre">binary()</span></code></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">atomvm-&lt;MAC&gt;</span></code> where <code class="docutils literal notranslate"><span class="pre">&lt;MAC&gt;</span></code> is the factory-assigned MAC-address of the device</p></td>
<td><p>WiFi AP SSID</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ssid_hidden</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">boolean()</span></code></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">false</span></code></p></td>
<td><p>Whether the AP SSID should be hidden (i.e., not broadcast)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">psk</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">string()</span> <span class="pre">|</span> <span class="pre">binary()</span></code></p></td>
<td><p>yes, if network is encrypted</p></td>
<td><p>-</p></td>
<td><p>WiFi AP password.  Warning: If this option is not specified, the network will be an open network, to which anyone who knows the SSID can connect and which is not encrypted.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ap_max_connections</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">non_neg_integer()</span></code></p></td>
<td><p>no</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">4</span></code></p></td>
<td><p>Maximum number of devices that can be connected to this AP</p></td>
</tr>
</tbody>
</table>
<p>If the ESP32 device starts the AP network successfully, the <code class="docutils literal notranslate"><span class="pre">ok</span></code> atom is returned; otherwise, an error is returned.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Config = [
    {psk,  &lt;&lt;&quot;mypsk&quot;&gt;&gt;}
],
case network:wait_for_ap(Config, 15000) of
    ok -&gt;
        io:format(&quot;AP network started at 192.168.4.1~n&quot;);
    {error, Reason} -&gt;
        io:format(&quot;Network initialization failed: ~p~n&quot;, [Reason])
end
</pre></div>
</div>
<p>Once the WiFi network is started, you may begin TCP or UDP networking, as described in more detail below.</p>
<p>For information about how to handle connections and disconnections from attached devices, see the <a class="reference internal" href="network-programming-guide.html"><span class="std std-doc">AtomVM Network Programming Guide</span></a>.</p>
</section>
<section id="sta-ap-mode">
<h4>STA+AP mode<a class="headerlink" href="#sta-ap-mode" title="Permalink to this heading"></a></h4>
<p>For information about how to run the AtomVM network in STA and AP mode simultaneously, see the <a class="reference internal" href="network-programming-guide.html"><span class="std std-doc">AtomVM Network Programming Guide</span></a>.</p>
</section>
<section id="sntp">
<h4>SNTP<a class="headerlink" href="#sntp" title="Permalink to this heading"></a></h4>
<p>For information about how to use SNTP to synchronize the clock on your device, see the <a class="reference internal" href="network-programming-guide.html"><span class="std std-doc">AtomVM Network Programming Guide</span></a>.</p>
</section>
</section>
<section id="udp">
<h3>UDP<a class="headerlink" href="#udp" title="Permalink to this heading"></a></h3>
<p>AtomVM supports network programming using the User Datagram Protocol (UDP) via the <code class="docutils literal notranslate"><span class="pre">gen_udp</span></code> module.  This modules obeys the syntax and semantics of the Erlang/OTP <a class="reference external" href="https://erlang.org/doc/man/gen_udp.html"><code class="docutils literal notranslate"><span class="pre">gen_udp</span></code></a> interface.</p>
<blockquote>
<div><p>Note.  Not all of the Erlang/OTP <code class="docutils literal notranslate"><span class="pre">gen_udp</span></code> functionality is implemented in AtomVM.  For details, consults the AtomVM API documentation.</p>
</div></blockquote>
<p>To open a UDP port, use the <code class="docutils literal notranslate"><span class="pre">gen_udp:open/1,2</span></code> function.  Supply a port number, and if your application plans to receive UDP messages, specify that the port is active via the <code class="docutils literal notranslate"><span class="pre">{active,</span> <span class="pre">true}</span></code> property in the optional properties list.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Port = 44404,
case gen_udp:open(Port, [{active, true}, binary]) of
    {ok, Socket} -&gt;
        {ok, SockName} = inet:sockname(Socket)
        io:format(&quot;Opened UDP socket on ~p.~n&quot;, [SockName])
    Error -&gt;
        io:format(&quot;An error occurred opening UDP socket: ~p~n&quot;, [Error])
end
</pre></div>
</div>
<p>If the port is active, you can receive UDP messages in your application.  They will be delivered as a 5-tuple, starting with the <code class="docutils literal notranslate"><span class="pre">udp</span></code> atom, and containing the socket, address and port from which the message was sent, as well as the datagram packet, itself, as a list (by default) or a binary. To choose the format, pass <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">binary</span></code> in options, as with Erlang/OTP.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
receive
    {udp, _Socket, Address, Port, Packet} -&gt;
        io:format(&quot;Received UDP packet ~p from address ~p port ~p~n&quot;, [Packet, Address, Port)])
end,
</pre></div>
</div>
<p>With a reference to a UDP <code class="docutils literal notranslate"><span class="pre">Socket</span></code>, you can send messages to a target UDP endpoint using the <code class="docutils literal notranslate"><span class="pre">gen_udp:send/4</span></code> function.  Specify the UDP socket returned from <code class="docutils literal notranslate"><span class="pre">gen_udp:open/1,2</span></code>, the address (as a 4-tuple of octets), port number, and the datagram packet to send:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Packet = &lt;&lt;&quot;:アトムＶＭ&quot;&gt;&gt;,
Address = {192, 168, 1, 101},
Port = 44404,
case gen_udp:send(Socket, Address, Port, Packet) of
    ok -&gt;
        io:format(&quot;Sent ~p~n&quot;, [Packet]);
    Error -&gt;
        io:format(&quot;An error occurred sending a packet: ~p~n&quot;, [Error])
end
</pre></div>
</div>
<blockquote>
<div><p>Note.  IPv6 networking is not currently supported in AtomVM.</p>
</div></blockquote>
</section>
<section id="tcp">
<h3>TCP<a class="headerlink" href="#tcp" title="Permalink to this heading"></a></h3>
<p>AtomVM supports network programming using the Transport Connection Protocol (TCP) via the <code class="docutils literal notranslate"><span class="pre">gen_tcp</span></code> module.  This modules obeys the syntax and semantics of the Erlang/OTP <a class="reference external" href="https://erlang.org/doc/man/gen_tcp.html"><code class="docutils literal notranslate"><span class="pre">gen_tcp</span></code></a> interface.</p>
<blockquote>
<div><p>Note.  Not all of the Erlang/OTP <code class="docutils literal notranslate"><span class="pre">gen_tcp</span></code> functionality is implemented in AtomVM.  For details, consults the AtomVM API documentation.</p>
</div></blockquote>
<section id="server-side-tcp">
<h4>Server-side TCP<a class="headerlink" href="#server-side-tcp" title="Permalink to this heading"></a></h4>
<p>Server side TCP requires opening a listening socket, and then waiting to accept connections from remote clients.  Once a connection is established, the application may then use a combination of sending and receiving packets over the established connection to or from the remote client.</p>
<blockquote>
<div><p>Note.  Programming TCP on the server-side using the <code class="docutils literal notranslate"><span class="pre">gen_tcp</span></code> interface is a subtle art, and this portion of the documentation will not go into all of the design choices available when designing a TCP application.</p>
</div></blockquote>
<p>Start by opening a listening socket using the <code class="docutils literal notranslate"><span class="pre">gen_tcp:listen/2</span></code> function.  Specify the port number on which the TCP server should be listening:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
case gen_tcp:listen(44405, []) of
    {ok, ListenSocket} -&gt;
        {ok, SockName} = inet:sockname(Socket),
        io:format(&quot;Listening for connections at address ~p.~n&quot;, [SockName]),
        spawn(fun() -&gt; accept(ListenSocket) end);
    Error -&gt;
        io:format(&quot;An error occurred listening: ~p~n&quot;, [Error])
end.
</pre></div>
</div>
<p>In this particular example, the server will spawn a new process to wait to accept a connection from a remote client, by calling the <code class="docutils literal notranslate"><span class="pre">gen_tcp:accept/1</span></code> function, passing in a reference to the listening socket.  This function will block until a client has established a connection with the server.</p>
<p>When a client connects, the function will return a tuple <code class="docutils literal notranslate"><span class="pre">{ok,</span> <span class="pre">Socket}</span></code>, where <code class="docutils literal notranslate"><span class="pre">Socket</span></code> is a reference to the connection between the client and server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
accept(ListenSocket) -&gt;
    io:format(&quot;Waiting to accept connection...~n&quot;),
    case gen_tcp:accept(ListenSocket) of
        {ok, Socket} -&gt;
            {ok, SockName} = inet:sockname(Socket),
            {ok, Peername} = inet:peername(Socket),
            io:format(&quot;Accepted connection.  local: ~p peer: ~p~n&quot;, [SockName, Peername]),
            spawn(fun() -&gt; accept(ListenSocket) end),
            echo();
        Error -&gt;
            io:format(&quot;An error occurred accepting connection: ~p~n&quot;, [Error])
    end.
</pre></div>
</div>
<blockquote>
<div><p>Note that immediately after accepting a connection, this example code will spawn a new process to accept any new connections from other clients.</p>
</div></blockquote>
<p>The socket returned from <code class="docutils literal notranslate"><span class="pre">gen_tcp:accept/1</span></code> can then be used to send and receive messages to the connected client:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
echo() -&gt;
    io:format(&quot;Waiting to receive data...~n&quot;),
    receive
        {tcp_closed, _Socket} -&gt;
            io:format(&quot;Connection closed.~n&quot;),
            ok;
        {tcp, Socket, Packet} -&gt;
            {ok, Peername} = inet:peername(Socket),
            io:format(&quot;Received packet ~p from ~p.  Echoing back...~n&quot;, [Packet, Peername]),
            gen_tcp:send(Socket, Packet),
            echo()
    end.
</pre></div>
</div>
<p>In this case, the server program will continuosuly echo the received input back to the client, until the client closes the connection.</p>
<p>For more information about the <code class="docutils literal notranslate"><span class="pre">gen_tcp</span></code> server interface, consult the AtomVM <a class="reference internal" href="#./api-reference-documentation.md"><span class="xref myst">API Reference Documentation</span></a>.</p>
</section>
<section id="client-side-tcp">
<h4>Client-side TCP<a class="headerlink" href="#client-side-tcp" title="Permalink to this heading"></a></h4>
<p>Client side TCP requires establishing a connection with an endpoint, and then using a combination of sending and receiving packets over the established connection.</p>
<p>Start by opening a connection to another TCP endpoint using the <code class="docutils literal notranslate"><span class="pre">gen_tcp:connect/3</span></code> function.  Supply the address and port of the TCP endpoint.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
Address = {192, 168, 1, 101},
Port = 44405,
case gen_tcp:connect(Address, Port, []) of
    {ok, Socket} -&gt;
        {ok, SockName} = inet:sockname(Socket),
        {ok, Peername} = inet:peername(Socket),
        io:format(&quot;Connected to ~p from ~p~n&quot;, [Peername, SockName]);
    Error -&gt;
        io:format(&quot;An error occurred connecting: ~p~n&quot;, [Error])
end
</pre></div>
</div>
<p>Once a connection is established, you can use a combination of</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>%% erlang
SendPacket = &lt;&lt;&quot;:アトムＶＭ&quot;&gt;&gt;,
case gen_tcp:send(Socket, SendPacket) of
    ok -&gt;
        receive
            {tcp_closed, _Socket} -&gt;
                io:format(&quot;Connection closed.~n&quot;),
                ok;
            {tcp, _Socket, ReceivedPacket} -&gt;
                {ok, Peername} = inet:peername(Socket),
                io:format(&quot;Received ~p from ~p~n&quot;, [ReceivedPacket, Peername])
        end;
    Error -&gt;
        io:format(&quot;An error occurred sending a packet: ~p~n&quot;, [Error])
end.
</pre></div>
</div>
<p>For more information about the <code class="docutils literal notranslate"><span class="pre">gen_tcp</span></code> client interface, consults the AtomVM API documentation.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="getting-started-guide.html" class="btn btn-neutral float-left" title="Getting Started Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="example-programs.html" class="btn btn-neutral float-right" title="Example Programs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2023, AtomVM.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <!--
 Copyright 2023 Winford (Uncle Grumpy) <winford@object.stream>

 SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later

 Based on the work of  Michael Altfield:
 https://tech.michaelaltfield.net/2020/07/18/sphinx-rtd-github-pages-1
-->



  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book">AtomVM Docs</span>
      v: master
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <dl>
        <dt>Versions</dt>
        
           <strong> 
          <dd><a href="/doc/master/">master</a></dd>
           </strong> 
        
          
          <dd><a href="/doc/release-0.5/">release-0.5</a></dd>
          
        
      </dl>
      
      
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="/doc/master/pdf/AtomVM-master.pdf">pdf</a></dd>
        
          <dd><a href="/doc/master/epub/AtomVM-master.epub">epub</a></dd>
        
      </dl>
      
    </div>
  </div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>